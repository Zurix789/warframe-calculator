<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warframe Crafting Manager</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚔️</text></svg>">
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        body {
            background-color: #f5f5f5;
            padding: 20px;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 20px;
        }
        
        h1, h2, h3 {
            color: #222;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
        }
        
        h2 {
            margin: 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid #eee;
        }
        
        h3 {
            margin: 15px 0 10px;
        }
        
        .tabs {
            display: flex;
            background-color: #f0f0f0;
            border-radius: 8px 8px 0 0;
            overflow: hidden;
            margin-bottom: 20px;
        }
        
        .tab {
            padding: 12px 24px;
            cursor: pointer;
            background-color: #e0e0e0;
            border: none;
            transition: background-color 0.3s;
            font-weight: 500;
            outline: none;
        }
        
        .tab:hover {
            background-color: #d0d0d0;
        }
        
        .tab.active {
            background-color: #4a7de9;
            color: white;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .form-container {
            background-color: #f4f4f4;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        .form-group label {
            display: block;
            margin-bottom: 5px;
        }
        
        .form-group input[type="text"],
        .form-group input[type="number"],
        .form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .btn {
            display: inline-flex;
            align-items: center;
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            transition: background-color 0.2s;
        }
        
        .btn:hover {
            background-color: #0069d9;
        }
        
        .btn-green {
            background-color: #28a745;
        }
        
        .btn-green:hover {
            background-color: #218838;
        }
        
        .btn-red {
            background-color: #dc3545;
        }
        
        .btn-red:hover {
            background-color: #c82333;
        }
        
        .btn-blue {
            background-color: #007bff;
        }
        
        .btn-blue:hover {
            background-color: #0069d9;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        
        table, th, td {
            border: 1px solid #ddd;
        }
        
        th, td {
            padding: 10px;
            text-align: left;
        }
        
        th {
            background-color: #f2f2f2;
        }
        
        .action-btns {
            display: flex;
            justify-content: center;
            gap: 10px;
        }
        
        .resource-selection {
            display: flex;
            flex-direction: column;
            gap: 10px;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #ddd;
            padding: 10px;
        }
        
        .resource-selection .resource-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .resource-selection .resource-item input[type="number"] {
            width: 80px;
        }
        
        .resource-icon {
            width: 24px;
            height: 24px;
            background-size: cover;
            background-position: center;
            display: inline-block;
            vertical-align: middle;
            margin-right: 5px;
        }
        
        .blueprint-cost {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-top: 5px;
        }
        
        .item-image {
            width: 100px;
            height: 100px;
            object-fit: cover;
            border-radius: 4px;
        }
        
        .hidden {
            display: none;
        }
        
        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
        }
        
        @media (min-width: 768px) {
            .grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        .card {
            background-color: #f9f9f9;
            border-radius: 6px;
            padding: 15px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background-color: white;
            border-radius: 4px;
            margin-bottom: 8px;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
        }
        
        .item-info {
            display: flex;
            flex-direction: column;
        }
        
        .item-name {
            font-weight: 600;
        }
        
        .item-source, .item-credits, .item-bp-credits, .item-category, .item-bp-standing, .item-bp-resource {
            font-size: 12px;
            color: #666;
        }
        
        .item-bp-credits {
            color: #4a7de9;
        }
        
        .item-bp-standing {
            color: #8e44ad;
        }
        
        .item-bp-resource {
            color: #27ae60;
        }
        
        .category-filter, .search-filter {
            margin-bottom: 15px;
        }
        
        .category-filter select, .search-filter input {
            padding: 6px 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            margin-left: 5px;
            width: 200px;
        }
        
        .items-list {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 5px;
        }
        
        .quantity-control {
            display: flex;
            align-items: center;
        }
        
        .quantity-control button {
            background-color: #ddd;
            color: #333;
            font-weight: bold;
        }
        
        .quantity-control button:hover {
            background-color: #ccc;
        }
        
        .quantity-display {
            padding: 6px 12px;
            background-color: #eee;
            margin: 0 4px;
        }
        
        .resources-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }
        
        @media (min-width: 768px) {
            .resources-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (min-width: 992px) {
            .resources-grid {
                grid-template-columns: 1fr 1fr 1fr;
            }
        }
        
        .resource-card {
            background-color: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .inventory-resource-card {
            background-color: white;
            border-radius: 6px;
            padding: 12px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .inventory-resource-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .inventory-quantity-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .inventory-quantity-input {
            width: 100px;
            padding: 6px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
        }
        
        .credit-input-container {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .credit-input-container input {
            flex: 1;
        }
        
        .resource-header {
            display: flex;
            align-items: center;
        }
        
        .resource-img {
            width: 36px;
            height: 36px;
            background-color: #eee;
            border-radius: 50%;
            margin-right: 12px;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            border: 1px solid #ddd;
        }
        
        .resource-img span {
            font-size: 18px;
        }
        
        .resource-img img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .resource-name {
            font-weight: 600;
        }
        
        .resource-quantity {
            font-weight: 700;
            font-size: 18px;
        }
        
        .resource-locations {
            margin-top: 8px;
            font-size: 12px;
            color: #666;
        }
        
        .resource-locations-title {
            font-weight: 600;
        }
        
        .credit-display {
            font-weight: 600;
            font-size: 18px;
            margin-bottom: 16px;
            background-color: #f5f5f5;
            padding: 10px;
            border-radius: 4px;
            border-left: 4px solid #4a7de9;
        }
        
        .credit-amount {
            color: #4a7de9;
            font-weight: 700;
        }
        
        .credit-breakdown {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
            max-width: 400px;
        }
        
        .empty-message {
            color: #888;
            text-align: center;
            padding: 10px;
        }
        
        .selected-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background-color: white;
            border-radius: 4px;
            margin-bottom: 10px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        
        .selected-item-header {
            margin-bottom: 5px;
        }
        
        .selected-item-name {
            font-weight: 600;
            font-size: 16px;
        }
        
        .selected-item-category {
            font-size: 12px;
            color: #4a7de9;
            font-weight: 500;
        }
        
        .selected-item-details {
            font-size: 13px;
            color: #666;
        }
        
        .selected-item-cost {
            margin-bottom: 2px;
        }
        
        .selected-item-total {
            font-weight: 600;
            color: #333;
            margin-top: 3px;
        }
        
        .selected-item-controls {
            display: flex;
            align-items: center;
        }
        
        .locations-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
        }
        
        .resource-image-preview {
            margin-top: 10px;
            display: flex;
            align-items: center;
        }
        
        .resource-image-preview img {
            max-width: 100px;
            max-height: 100px;
            margin-right: 10px;
        }
        
        .no-image {
            color: #999;
            font-style: italic;
        }
        
        .resource-details-container {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .resource-item-display {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        
        /* Save notification */
        .save-notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 10px 20px;
            background-color: #28a745;
            color: white;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .save-notification.show {
            opacity: 1;
            transform: translateY(0);
        }
        
        /* Syndicate Manager Styles */
        .syndicate-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .syndicate-card {
            background-color: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .syndicate-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .syndicate-logo {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            overflow: hidden;
            margin-right: 15px;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .syndicate-logo img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .syndicate-info {
            flex: 1;
        }
        
        .syndicate-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .syndicate-description {
            color: #666;
            font-size: 14px;
        }
        
        .syndicate-ranks {
            margin-top: 10px;
        }
        
        .rank-item {
            padding: 8px;
            border-radius: 4px;
            background-color: #f5f5f5;
            margin-bottom: 8px;
        }
        
        .rank-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
        }
        
        .rank-requirements {
            margin-top: 5px;
            font-size: 13px;
            color: #555;
        }
        
        .manage-ranks-btn {
            margin-top: 10px;
        }
        
        .syndicate-actions {
            display: flex;
            justify-content: flex-end;
            margin-top: 15px;
            gap: 10px;
        }
        
        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            overflow: auto;
        }
        
        .modal-content {
            background-color: white;
            margin: 5% auto;
            padding: 20px;
            border-radius: 8px;
            width: 80%;
            max-width: 800px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .close-modal {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        
        .close-modal:hover {
            color: #000;
        }
        
        /* Mastery Tracker Styles */
        .mastery-status {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 11px;
            font-weight: bold;
            margin-left: 8px;
        }
        
        .mastered {
            background-color: #28a745;
            color: white;
        }
        
        .not-mastered {
            background-color: #dc3545;
            color: white;
        }
        
        .mastery-filter {
            margin-bottom: 15px;
            padding: 8px;
            background-color: #f0f0f0;
            border-radius: 4px;
        }
        
        .mastery-filter label {
            margin-right: 15px;
            cursor: pointer;
        }
        
        .mastery-indicator {
            display: inline-block;
            transition: background-color 0.3s ease;
            user-select: none;
        }
        
        .mastery-indicator:hover {
            opacity: 0.9;
        }
        
        .mastery-controls {
            margin-top: 15px;
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .mastery-count {
            font-weight: bold;
            margin-left: auto;
        }
        
        .auto-calculate-btn {
            margin-bottom: 15px;
        }
        
        .blueprint-checkbox {
            margin-top: 5px;
            display: flex;
            align-items: center;
        }
        
        .blueprint-checkbox input[type="checkbox"] {
            margin-right: 5px;
        }
        
        .blueprint-input {
            margin-top: 5px;
            display: flex;
            align-items: center;
        }
        
        .blueprint-input label {
            margin-right: 5px;
        }
        
        .blueprint-quantity-input {
            width: 60px;
            padding: 2px 5px;
            text-align: center;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .selected-item-blueprint {
            margin-bottom: 10px;
        }
        
        .selected-item-cost {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .selected-item-total {
            margin-top: 8px;
            font-weight: 600;
            border-top: 1px solid #eee;
            padding-top: 5px;
        }
        
        .blueprint-info {
            margin-top: 5px;
            font-size: 13px;
            color: #555;
        }
        
        .blueprint-info-label {
            margin-right: 5px;
            font-weight: 500;
        }
        
        .blueprint-info-value {
            font-style: italic;
        }
        
        .blueprint-info-infinite {
            color: purple;
        }
        
        .blueprint-info-multi {
            color: blue;
        }
        
        .mastery-summary {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 8px;
        }
        
        .progress-container {
            width: 300px;
            height: 25px;
            background-color: #e0e0e0;
            border-radius: 12.5px;
            overflow: hidden;
            position: relative;
            margin-top: 10px;
        }
        
        .progress-bar {
            height: 100%;
            background-color: #4a7de9;
            width: 0%; /* Will be set dynamically via JS */
            transition: width 0.3s ease;
        }
        
        .progress-text {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            font-weight: bold;
            text-shadow: 0 0 2px rgba(255, 255, 255, 0.7);
        }
        
        .mastery-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
            background-color: #f0f0f0;
            padding: 10px;
            border-radius: 8px;
        }
        
        .mastery-display-filter {
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        .mastery-items-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .mastery-item {
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .mastery-item:hover {
            transform: translateY(-3px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .mastery-item-image {
            width: 100%;
            height: 120px;
            object-fit: cover;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .mastery-item-image img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }
        
        .mastery-item-details {
            padding: 10px;
        }
        
        .mastery-item-name {
            font-weight: 600;
            margin-bottom: 5px;
        }
        
        .mastery-item-category {
            font-size: 12px;
            color: #666;
            margin-bottom: 8px;
        }
        
        .mastery-checkbox {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            user-select: none;
            padding: 5px;
            background-color: #f9f9f9;
            border-radius: 4px;
        }
        
        .mastery-checkbox:hover {
            background-color: #eee;
        }
        
        .mastery-checkbox input {
            cursor: pointer;
        }
        
        .mastery-checkbox.mastered {
            background-color: #d4edda;
            color: #155724;
        }
        
        .mastery-checkbox.unmastered {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        /* Blueprint Sources Container */
        .blueprint-sources-container, .calculator-source {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-width: 100%;
            width: 100%;
        }
        
        /* Blueprint Source Entry */
        .blueprint-source-entry, .calculator-source-entry {
            padding: 6px 8px;
            border-radius: 4px;
            background-color: #f8f9fa;
            border-left: 3px solid #ddd;
            margin-bottom: 5px;
            font-size: 13px;
        }
        
        /* Source Type */
        .blueprint-source-type, .calculator-source-type {
            font-weight: 600;
            margin-bottom: 3px;
        }
        
        /* Source Details */
        .blueprint-source-details, .calculator-source-details {
            color: #555;
            font-size: 12px;
            line-height: 1.4;
        }
        
        /* Detail Labels */
        .detail-label {
            font-weight: 500;
            color: #666;
        }
        
        /* Detail Values */
        .detail-value {
            color: #333;
        }
        
        /* Special formatting for rarity values */
        .detail-rarity-common {
            color: #7f7f7f;
            font-weight: normal;
        }
        
        .detail-rarity-uncommon {
            color: #5c7eff;
            font-weight: 500;
        }
        
        .detail-rarity-rare {
            color: #d4af37;
            font-weight: 600;
        }
        
        /* Legacy source display */
        .blueprint-source-legacy, .calculator-source-legacy {
            padding: 6px 8px;
            background-color: #f8f9fa;
            border-left: 3px solid #aaa;
            border-radius: 4px;
            font-size: 13px;
        }
        
        /* No source display */
        .blueprint-source-none, .calculator-source-none {
            padding: 6px 8px;
            background-color: #f8f9fa;
            border-left: 3px solid #ddd;
            border-radius: 4px;
            color: #999;
            font-style: italic;
            font-size: 13px;
        }
        
        /* Blueprint Sources Cell - wider to show details */
        .blueprint-sources-cell {
            min-width: 250px;
            max-width: 350px;
        }
        
        /* Source Filter Container */
        .source-filter-container {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            padding: 10px;
            background-color: #f5f5f5;
            border-radius: 6px;
            flex-wrap: wrap;
        }
        
        .blueprint-source-filter, .blueprint-source-detail-filter {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .blueprint-source-filter select, .blueprint-source-detail-filter input {
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }
        
        .blueprint-source-detail-filter input {
            min-width: 250px;
        }
        
        /* Blueprint Source Details Container */
        .blueprint-source-details-container {
            margin-top: 12px;
            padding: 8px 10px;
            background-color: #eef5ff;
            border-radius: 6px;
            border-left: 4px solid #4682b4;
        }
        
        .blueprint-source-header, .component-source-header {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 14px;
        }
        
        /* Component Blueprint Source */
        .component-blueprint-source {
            margin-top: 8px;
            padding: 6px 8px;
            background-color: #f0f8ff;
            border-radius: 4px;
            border-left: 3px solid #4682b4;
            font-size: 11px;
        }
        
        /* Toggle button for additional sources */
        .source-toggle-btn {
            background-color: #e9ecef;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            color: #495057;
            margin-top: 2px;
        }
        
        .source-toggle-btn:hover {
            background-color: #dee2e6;
        }
        
        /* Additional sources container */
        .additional-sources {
            margin-top: 4px;
            padding-top: 4px;
            border-top: 1px dashed #ccc;
        }
        
        /* Blueprint source entry styles for different types */
        .blueprint-source-entry, .source-type-container {
            display: flex;
            flex-wrap: wrap;
            margin-bottom: 12px;
            padding: 10px;
            background-color: #f9f9fa;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }
        
        .source-type-container {
            flex: 1;
            min-width: 200px;
            margin-right: 10px;
        }
        
        .source-details-container {
            flex: 2;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            min-width: 300px;
        }
        
        .source-field {
            display: flex;
            align-items: center;
            margin-right: 10px;
        }
        
        .source-field label {
            margin-right: 5px;
            white-space: nowrap;
        }
        
        .remove-source-btn {
            margin-left: auto;
            height: 30px;
            align-self: center;
        }
        
        .blueprint-source-list {
            margin-bottom: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        
        #addBlueprintSourceBtn {
            margin-bottom: 15px;
        }
        
        /* Source Type Colors */
        .source-group-quest {
            border-left-color: #9c27b0; /* Purple */
        }
        
        .source-group-boss {
            border-left-color: #e53935; /* Red */
        }
        
        .source-group-syndicate {
            border-left-color: #43a047; /* Green */
        }
        
        .source-group-mission {
            border-left-color: #1976d2; /* Blue */
        }
        
        .source-group-relic {
            border-left-color: #fb8c00; /* Orange */
        }
        
        .source-group-enemy {
            border-left-color: #757575; /* Gray */
        }
        
        .source-group-bounty {
            border-left-color: #ffb300; /* Amber */
        }
        
        .source-group-lab {
            border-left-color: #00acc1; /* Cyan */
        }
        
        .source-group-market {
            border-left-color: #3949ab; /* Indigo */
        }
        
        .source-group-other {
            border-left-color: #8d6e63; /* Brown */
        }
    </style>
</head>
<body>
    <div id="saveNotification" class="save-notification">Data saved successfully!</div>
    
    <div class="container">
        <h1>Warframe Crafting Manager</h1>
        
        <div class="tabs">
            <!-- <button class="tab" data-tab="resources">Resource Manager</button>
            <button class="tab" data-tab="items">Item Manager</button> -->
            <button class="tab active" data-tab="inventory">Inventory Tracker</button>
            <!-- <button class="tab" data-tab="syndicates">Syndicate Manager</button> -->
            <button class="tab" data-tab="calculator">Crafting Calculator</button>
            <button class="tab" data-tab="mastery">Mastery Tracker</button>
        </div>
        
        <!-- Resource Manager Tab -->
        <div id="resources" class="tab-content">
            <h2>Warframe Resource Manager</h2>

            <div class="form-container">
                <div class="form-group">
                    <label for="resourceName">Resource Name</label>
                    <input type="text" id="resourceName" placeholder="Enter resource name">
                </div>

                <div class="form-group">
                    <label for="rarity">Rarity</label>
                    <select id="rarity">
                        <option>Common</option>
                        <option>Uncommon</option>
                        <option>Rare</option>
                        <option>Research</option>
                        <option>Navigation</option>
                        <option>Special</option>
                        <option>Sentient</option>
                        <option>Narmer</option>
                        <option>Event</option>
                        <option>Mining</option>
                        <option>Fishing</option>
                        <option>Bonds</option>
                        <option>Systems</option>
                        <option>Toroid</option>
                        <option>Residue</option>
                        <option>Tokens</option>
                        <option>Orokin Matrix</option>
                        <option>Necramech</option>
                        <option>Quest</option>
                        <option>Plants</option>
                        <option>Hex Treasures</option>
                        <option>Syndicate</option>
                        <option>Other</option>
                    </select>
                </div>

                <div class="form-group">
                    <label>Locations</label>
                    <div id="locationsGrid" class="locations-grid">
                        <label><input type="checkbox" value="Mercury"> Mercury</label>
                        <label><input type="checkbox" value="Venus"> Venus</label>
                        <label><input type="checkbox" value="Earth"> Earth</label>
                        <label><input type="checkbox" value="Lua"> Lua</label>
                        <label><input type="checkbox" value="Mars"> Mars</label>
                        <label><input type="checkbox" value="Deimos"> Deimos</label>
                        <label><input type="checkbox" value="Phobos"> Phobos</label>
                        <label><input type="checkbox" value="Ceres"> Ceres</label>
                        <label><input type="checkbox" value="Jupiter"> Jupiter</label>
                        <label><input type="checkbox" value="Europa"> Europa</label>
                        <label><input type="checkbox" value="Saturn"> Saturn</label>
                        <label><input type="checkbox" value="Uranus"> Uranus</label>
                        <label><input type="checkbox" value="Neptune"> Neptune</label>
                        <label><input type="checkbox" value="Pluto"> Pluto</label>
                        <label><input type="checkbox" value="Sedna"> Sedna</label>
                        <label><input type="checkbox" value="Eris"> Eris</label>
                        <label><input type="checkbox" value="Kuva Fortress"> Kuva Fortress</label>
                        <label><input type="checkbox" value="Void"> Void</label>
                        <label><input type="checkbox" value="Zariman"> Zariman</label>
                        <label><input type="checkbox" value="Empyrean"> Empyrean</label>
                        <label><input type="checkbox" value="Plains of Eidolon"> Plains of Eidolon</label>
                        <label><input type="checkbox" value="Orb Vallis"> Orb Vallis</label>
                        <label><input type="checkbox" value="Cambion Drift"> Cambion Drift</label>
                        <label><input type="checkbox" value="Duviri"> Duviri</label>
                        <label><input type="checkbox" value="Miscellaneous"> Miscellaneous</label>
                        <label><input type="checkbox" value="Höllvania"> Höllvania</label>
                        <label><input type="checkbox" value="Albrecht's Laboratories"> Albrecht's Laboratories</label>
                    </div>
                </div>

                <div class="form-group">
                    <label for="imageUrl">Image URL</label>
                    <input type="text" id="imageUrl" placeholder="Enter image URL">
                    <div class="resource-image-preview" id="imagePreview"></div>
                </div>

                <div>
                    <button id="addResourceBtn" class="btn">Add Resource</button>
                    <button id="exportResourcesBtn" class="btn btn-green">Export to JSON</button>
                    <button id="importResourcesBtn" class="btn btn-blue">Import from JSON</button>
                    <input type="file" id="resourcesFileInput" style="display: none;" accept=".json">
                    <button id="clearResourcesBtn" class="btn btn-red">Clear All Resources</button>
                    <button id="sortResourcesBtn" class="btn btn-blue">Sort Resources</button>
                </div>
            </div>

            <div>
                <h3>Current Resources</h3>
                <table id="resourcesTable">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th>Name</th>
                            <th>Rarity</th>
                            <th>Locations</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="resourcesList"></tbody>
                </table>
            </div>
        </div>
        
        <!-- Item Manager Tab -->
        <div id="items" class="tab-content">
            <h2>Warframe Item Manager</h2>

            <div class="form-container">
                <div class="form-group">
                    <label for="itemName">Item Name</label>
                    <input type="text" id="itemName" placeholder="Enter item name">
                </div>

                <div class="form-group">
                    <label for="itemCategory">Item Category</label>
                    <select id="itemCategory">
                        <option value="">Select Category</option>
                        <option value="Warframes">Warframes</option>
                        <option value="Archwings">Archwings</option>
                        <option value="Necramech">Necramech</option>
                        <option value="Primary Weapon">Primary Weapon</option>
                        <option value="Secondary Weapon">Secondary Weapon</option>
                        <option value="Melee Weapon">Melee Weapon</option>
                        <option value="Archgun">Archgun</option>
                        <option value="Arch-Melee">Arch-Melee</option>
                        <option value="Sentinel">Sentinel</option>
                        <option value="Robotic Weapon">Robotic Weapon</option>
                        <option value="Kitgun">Kitgun</option>
                        <option value="Zaw">Zaw</option>
                        <option value="Amp">Amp</option>
                        <option value="MOA">MOA</option>
                        <option value="Infested Companion">Infested Companion</option>
                        <option value="K-Drive">K-Drive</option>
                        <option value="Hound">Hound</option>
                        <option value="Quest">Quest</option>
                        <option value="Syndicate">Syndicate</option>
                        <option value="Component">Component</option>
                        <option value="Other">Other</option>
                        <option value="Decoration">Decoration</option>
                        <option value="Cosmetic">Cosmetic</option>
                        <option value="Railjack">Railjack</option>
                        <option value="Crafting">Crafting</option>
                        <option value="Gear">Gear</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="itemImage">Item Image URL</label>
                    <input type="text" id="itemImage" placeholder="Enter item image URL">
                </div>

                <div class="form-group">
                    <label for="blueprintSources">Blueprint Sources</label>
                    <div id="blueprintSourceList" class="blueprint-source-list">
                        <!-- Sources will be added here -->
                    </div>
                    <button id="addBlueprintSourceBtn" class="btn btn-blue">Add Source</button>
                </div>

                <div id="blueprintSourceTemplate" style="display: none;">
                    <div class="blueprint-source-entry">
                        <div class="source-type-container">
                            <select class="blueprintSourceType">
                                <option value="">Select Source Type</option>
                                <option value="Bought from Market">Bought from Market</option>
                                <option value="Reward from Quest">Reward from Quest</option>
                                <option value="Replicated from Lab">Replicated from Lab</option>
                                <option value="Sold by Syndicate">Sold by Syndicate</option>
                                <option value="Boss Drop">Boss Drop</option>
                                <option value="Mission Reward">Mission Reward</option>
                                <option value="Sanctuary Onslaught">Sanctuary Onslaught</option>
                                <option value="Junction Reward">Junction Reward</option>
                                <option value="Enemy Drop">Enemy Drop</option>
                                <option value="Bounty Reward">Bounty Reward</option>
                                <option value="Operation Purchase">Operation Purchase</option>
                                <option value="Abandoned Derelict Cache">Abandoned Derelict Cache</option>
                                <option value="Enigma Puzzles">Enigma Puzzles</option>
                                <option value="Invasion Reward">Invasion Reward</option>
                                <option value="Nightwave Offering">Nightwave Offering</option>
                                <option value="Assassin Drop">Assassin Drop</option>
                                <option value="Void Relics">Void Relics</option>
                                <option value="None">None</option>
                            </select>
                        </div>
                        
                        <!-- Dynamic fields will be added here based on source type -->
                        <div class="source-details-container"></div>
                        
                        <button class="btn btn-red remove-source-btn">Remove</button>
                    </div>
                </div>
                                <div class="form-group">
                    <div class="blueprint-cost">
                        <select id="blueprintCostType">
                            <option value="">Select Type</option>
                            <option value="Credits">Credits</option>
                            <option value="Standing">Standing</option>
                            <option value="Resource">Resource</option>
                        </select>
                        <select id="blueprintCostResource" class="hidden">
                            <option value="">Select Resource</option>
                            <!-- Resources will be dynamically populated here -->
                        </select>
                        <input type="number" id="blueprintCostQuantity" placeholder="Quantity" min="1">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="blueprintOptions">Blueprint Options</label>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin-top: 5px;">
                        <div>
                            <input type="checkbox" id="infiniteUses"> Reusable Blueprint
                        </div>
                        <div>
                            <input type="checkbox" id="multiItemBlueprint" onchange="toggleMultiItemFields()"> Creates multiple items per blueprint
                        </div>
                    </div>
                    <div id="multiItemCountContainer" class="hidden" style="margin-top: 10px;">
                        <label for="itemsPerBlueprint">Items per Blueprint:</label>
                        <input type="number" id="itemsPerBlueprint" min="1" value="1" style="width: 80px;">
                    </div>
                </div>
                
                <div class="form-group">
                    <label for="buildCreditCost">Build Credit Cost</label>
                    <input type="number" id="buildCreditCost" placeholder="Enter credit cost for building">
                </div>

                <div class="form-group">
                    <label>Required Resources</label>
                    <div id="resourceSelection" class="resource-selection">
                        <div class="resource-item">
                            <select class="resourceName">
                                <option value="">Select Resource or Item</option>
                                <!-- Resources and items will be dynamically populated here -->
                            </select>
                            <input type="number" class="resourceQuantity" placeholder="Quantity" min="1">
                            <button class="addResourceBtn btn">Add Resource</button>
                        </div>
                    </div>
                    <ul id="selectedResources"></ul>
                </div>

                <div>
                    <button id="refreshResourceBtn" class="btn btn-blue">Refresh Resource List</button>
                    <button id="addItemBtn" class="btn">Add Item</button>
                    <button id="exportItemsBtn" class="btn btn-green">Export Items</button>
                    <button id="importItemsBtn" class="btn btn-blue">Import from JSON</button>
                    <input type="file" id="itemsFileInput" style="display: none;" accept=".json">
                    <button id="clearItemsBtn" class="btn btn-red">Clear All Items</button>
                    <button id="sortItemsBtn" class="btn btn-blue">Sort Items</button>
                </div>
            </div>

            <div class="source-filter-container">
                <div class="blueprint-source-filter">
                    <label for="source-type-filter">Filter by Source Type:</label>
                    <select id="source-type-filter" onchange="filterItemsBySourceType()">
                        <option value="All">All Sources</option>
                        <option value="Bought from Market">Market</option>
                        <option value="Reward from Quest">Quest</option>
                        <option value="Replicated from Lab">Lab</option>
                        <option value="Sold by Syndicate">Syndicate</option>
                        <option value="Boss Drop">Boss</option>
                        <option value="Mission Reward">Mission</option>
                        <option value="Junction Reward">Junction</option>
                        <option value="Enemy Drop">Enemy</option>
                        <option value="Bounty Reward">Bounty</option>
                        <option value="Assassin Drop">Assassin</option>
                        <option value="Void Relics">Relic</option>
                        <option value="None">No Source</option>
                    </select>
                </div>
                
                <div class="blueprint-source-detail-filter">
                    <label for="source-detail-filter">Search Source Details:</label>
                    <input type="text" id="source-detail-filter" placeholder="E.g., Vor, Venus, Steel Meridian..." onkeyup="filterItemsBySourceDetail()">
                </div>
            </div>

            <div>
                <h3>Current Items</h3>
                <table id="itemsTable">
                    <thead>
                        <tr>
                            <th>Image</th>
                            <th>Name</th>
                            <th>Category</th>
                            <th>Blueprint Source</th>
                            <th>Blueprint Cost</th>
                            <th>Build Credit Cost</th>
                            <th>Build Resources</th>
                            <th>Actions</th>
                        </tr>
                    </thead>
                    <tbody id="itemsList"></tbody>
                </table>
            </div>
        </div>
        
        <!-- Syndicate Manager Tab -->
        <div id="syndicates" class="tab-content">
            <h2>Warframe Syndicate Manager</h2>
            
            <div class="form-container">
                <div class="form-group">
                    <label for="syndicateName">Syndicate Name</label>
                    <input type="text" id="syndicateName" placeholder="Enter syndicate name">
                </div>
                
                <div class="form-group">
                    <label for="syndicateDescription">Description (Optional)</label>
                    <input type="text" id="syndicateDescription" placeholder="Enter syndicate description">
                </div>
                
                <div class="form-group">
                    <label for="syndicateImage">Logo URL (Optional)</label>
                    <input type="text" id="syndicateImage" placeholder="Enter syndicate logo URL">
                </div>
                
                <div>
                    <button id="addSyndicateBtn" class="btn">Add Syndicate</button>
                    <button id="clearSyndicatesBtn" class="btn btn-red">Clear All Syndicates</button>
                </div>
            </div>
            
            <div id="syndicatesList" class="syndicate-list">
                <div class="empty-message">No syndicates added yet</div>
            </div>
            
            <!-- Rank Management Modal -->
            <div id="rankModal" class="modal">
                <div class="modal-content">
                    <span class="close-modal">&times;</span>
                    <h3>Manage <span id="currentSyndicateName"></span> Ranks</h3>
                    
                    <div class="form-container">
                        <div class="form-group">
                            <label for="rankName">Rank Name</label>
                            <input type="text" id="rankName" placeholder="Enter rank name">
                        </div>
                        
                        <div class="form-group">
                            <label for="standingRequired">Standing Required</label>
                            <input type="number" id="standingRequired" placeholder="Enter standing required" min="0">
                        </div>
                        
                        <div class="form-group">
                            <label for="initiationCredits">Initiation Credit Cost</label>
                            <input type="number" id="initiationCredits" placeholder="Enter credit cost" min="0">
                        </div>
                        
                        <div class="form-group">
                            <label>Required Resources</label>
                            <div id="rankResourceSelection" class="resource-selection">
                                <div class="resource-item">
                                    <select class="resourceName" id="rankResourceName">
                                        <option value="">Select Resource</option>
                                        <!-- Resources will be dynamically populated here -->
                                    </select>
                                    <input type="number" class="resourceQuantity" id="rankResourceQuantity" placeholder="Quantity" min="1">
                                    <button class="addResourceBtn btn">Add Resource</button>
                                </div>
                            </div>
                            <ul id="rankSelectedResources"></ul>
                        </div>
                        
                        <button id="addRankBtn" class="btn">Add Rank</button>
                    </div>
                    
                    <div>
                        <h4>Current Ranks</h4>
                        <div id="syndicateRanksList">
                            <div class="empty-message">No ranks added yet</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Inventory Tracker Tab -->
        <div id="inventory" class="tab-content active">
            <h2>Warframe Inventory Tracker</h2>
            
            <div class="form-container">
                <div class="form-group">
                    <label for="currentCredits">Current Credits</label>
                    <div class="credit-input-container">
                        <input type="number" id="currentCredits" placeholder="Enter your current credits" min="0">
                        <button id="saveCreditsBtn" class="btn">Save Credits</button>
                    </div>
                </div>
                <button id="sortInventoryBtn" class="btn btn-blue">Auto-Sort Inventory</button>
            </div>
            
            <div class="card">
                <h3>Resource Inventory</h3>
                <div class="location-tabs" style="margin-bottom: 15px; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; display: flex; flex-wrap: wrap;">
    <button class="location-tab active" data-location="All" style="padding: 8px 12px; border: none; background: #4a7de9; color: white; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">All</button>
    <button class="location-tab" data-location="Star Chart" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Star Chart</button>
    <button class="location-tab" data-location="Empyrean" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Empyrean</button>
    <button class="location-tab" data-location="Plains of Eidolon" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Plains of Eidolon</button>
    <button class="location-tab" data-location="Orb Vallis" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Orb Vallis</button>
    <button class="location-tab" data-location="Cambion Drift" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Cambion Drift</button>
    <button class="location-tab" data-location="Duviri" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Duviri</button>
    <button class="location-tab" data-location="Höllvania" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Höllvania</button>
    <button class="location-tab" data-location="Miscellaneous" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Miscellaneous</button>
</div>
                <div class="search-filter">
                    <label for="inventory-search">Search Resources: </label>
                    <input type="text" id="inventory-search" placeholder="Search resources..." onkeyup="filterInventoryResources()">
                </div>
                <div id="resource-inventory" class="resources-grid">
                    <div class="empty-message">No resources available. Add resources in the Resource Manager tab first.</div>
                </div>
            </div>

            <div class="card">
                <h3>Item Inventory</h3>
                <!-- Main Category Tabs -->
<div class="item-category-tabs" style="margin-bottom: 15px; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; display: flex; flex-wrap: wrap;">
    <button class="item-category-tab active" data-category="All" style="padding: 8px 12px; border: none; background: #4a7de9; color: white; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">All</button>
    <button class="item-category-tab" data-category="Warframes" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Warframes</button>
    <button class="item-category-tab" data-category="Vehicles" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Vehicles</button>
    <button class="item-category-tab" data-category="Weapons" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Weapons</button>
    <button class="item-category-tab" data-category="Companions" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Companions</button>
    <button class="item-category-tab" data-category="Quest" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Quest</button>
    <button class="item-category-tab" data-category="Syndicate" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Syndicate</button>
    <button class="item-category-tab" data-category="Component" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Parts</button>
    <button class="item-category-tab" data-category="Decoration" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Decoration</button>
    <button class="item-category-tab" data-category="Cosmetic" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Cosmetic</button>
    <button class="item-category-tab" data-category="Railjack" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Railjack</button>
    <button class="item-category-tab" data-category="Crafting" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Crafting</button>
    <button class="item-category-tab" data-category="Gear" style="padding: 8px 12px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s;">Gear</button>
</div>

<!-- Vehicle Subcategory Tabs (initially hidden) -->
<div class="item-subcategory-tabs vehicle-tabs" style="margin-bottom: 15px; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; display: none; flex-wrap: wrap;">
    <button class="item-subcategory-tab active" data-subcategory="All" style="padding: 6px 10px; border: none; background: #4a7de9; color: white; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">All Vehicles</button>
    <button class="item-subcategory-tab" data-subcategory="Archwings" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Archwings</button>
    <button class="item-subcategory-tab" data-subcategory="Necramech" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Necramechs</button>
    <button class="item-subcategory-tab" data-subcategory="K-Drive" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">K-Drive</button>
</div>

<!-- Weapon Subcategory Tabs (initially hidden) -->
<div class="item-subcategory-tabs weapon-tabs" style="margin-bottom: 15px; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; display: none; flex-wrap: wrap;">
    <button class="item-subcategory-tab active" data-subcategory="All" style="padding: 6px 10px; border: none; background: #4a7de9; color: white; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">All Weapons</button>
    <button class="item-subcategory-tab" data-subcategory="Primary Weapon" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Primary</button>
    <button class="item-subcategory-tab" data-subcategory="Secondary Weapon" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Secondary</button>
    <button class="item-subcategory-tab" data-subcategory="Melee Weapon" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Melee</button>
    <button class="item-subcategory-tab" data-subcategory="Archgun" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Archgun</button>
    <button class="item-subcategory-tab" data-subcategory="Arch-Melee" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Arch-Melee</button>
    <button class="item-subcategory-tab" data-subcategory="Kitgun" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Kitgun</button>
    <button class="item-subcategory-tab" data-subcategory="Zaw" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Zaw</button>
    <button class="item-subcategory-tab" data-subcategory="Amp" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Amp</button>
    <button class="item-subcategory-tab" data-subcategory="Robotic Weapon" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Companion</button>
</div>

<!-- Companion Subcategory Tabs (initially hidden) -->
<div class="item-subcategory-tabs companion-tabs" style="margin-bottom: 15px; background-color: #f0f0f0; border-radius: 4px; overflow: hidden; display: none; flex-wrap: wrap;">
    <button class="item-subcategory-tab active" data-subcategory="All" style="padding: 6px 10px; border: none; background: #4a7de9; color: white; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">All Companions</button>
    <button class="item-subcategory-tab" data-subcategory="Robotic" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Robotic</button>
    <button class="item-subcategory-tab" data-subcategory="Organic" style="padding: 6px 10px; border: none; background: #e0e0e0; color: #333; cursor: pointer; font-weight: 500; transition: background-color 0.3s; font-size: 0.9em;">Organic</button>
</div>
                <div class="search-filter">
                    <label for="inventory-items-search">Search Items: </label>
                    <input type="text" id="inventory-items-search" placeholder="Search items..." onkeyup="filterInventoryItems()">
                </div>
                <div id="item-inventory" class="resources-grid">
                    <div class="empty-message">No items available. Add items in the Item Manager tab first.</div>
                </div>
            </div>
        </div>

        <!-- Calculator Tab -->
        <div id="calculator" class="tab-content">
            <h2>Warframe Crafting Calculator</h2>
            
            <div class="form-container">
                <div class="mastery-filter">
                    <label><input type="checkbox" id="exclude-mastered" checked> Exclude mastered items</label>
                    <span>(Except for Quest, Syndicate, Component, Other, Decoration, Railjack, Crafting, Gear)</span>
                </div>
            </div>
            
            <div class="grid">
                <div>
                    <h3>Available Items</h3>
                    <div class="card" id="available-items">
                        <div class="empty-message">Select items to craft</div>
                    </div>
                </div>
                
                <div>
                    <h3>Selected Items</h3>
                    <div class="card" id="selected-items">
                        <div class="empty-message">No items selected</div>
                    </div>
                </div>
            </div>
            
            <h3>Total Resources Required</h3>
            <div class="card">
                <div class="credit-display" id="total-credits">Credits: 0</div>
                <div id="total-resources">
                    <div class="empty-message">No resources required yet</div>
                </div>
            </div>
        </div>

        <!-- Mastery Tracker Tab -->
        <div id="mastery" class="tab-content">
            <h2>Warframe Mastery Tracker</h2>
            
            <div class="mastery-summary">
                <div class="mastery-count">
                    <h3>Mastery Progress</h3>
                    <div class="progress-container">
                        <div class="progress-bar" id="mastery-progress-bar"></div>
                        <div class="progress-text">
                            Mastered: <span id="mastery-total-count">0</span>/<span id="mastery-available-count">0</span>
                        </div>
                    </div>
                </div>
                <div class="mastery-controls">
                    <button class="btn btn-green" id="mark-all-mastered-btn">Mark All Mastered</button>
                    <button class="btn btn-red" id="mark-all-unmastered-btn">Mark All Unmastered</button>
                    <button class="btn btn-blue" id="add-unmastered-to-calc-btn">Add Unmastered to Calculator</button>
                </div>
            </div>
            
            <div class="mastery-filters">
                <div class="category-filter">
                    <label for="mastery-category-select">Filter by Category: </label>
                    <select id="mastery-category-select" onchange="filterMasteryByCategory()">
                        <option value="All">All Categories</option>
                        <!-- Categories will be dynamically populated -->
                    </select>
                </div>
                <div class="search-filter">
                    <label for="mastery-search">Search: </label>
                    <input type="text" id="mastery-search" placeholder="Search items..." onkeyup="filterMasteryBySearch()">
                </div>
                <div class="mastery-display-filter">
                    <label>
                        <input type="radio" name="mastery-filter" value="all" checked onchange="filterMasteryByStatus()"> 
                        Show All
                    </label>
                    <label>
                        <input type="radio" name="mastery-filter" value="mastered" onchange="filterMasteryByStatus()"> 
                        Show Mastered
                    </label>
                    <label>
                        <input type="radio" name="mastery-filter" value="unmastered" onchange="filterMasteryByStatus()"> 
                        Show Unmastered
                    </label>
                </div>
            </div>
            
            <div class="mastery-items-grid" id="mastery-items-container">
                <!-- Items will be dynamically populated here -->
            </div>
        </div>
    </div>

    <script>

        // Global data stores for resources and items
        let resources = [];
        let items = [];
        let selectedItems = [];
        let syndicates = [];
        let currentSyndicateIndex = -1;
        let inventory = {
            credits: 0,
            resources: {},
            masteredItems: {},
            items: {},
            blueprints: {}
        };
        
        // Categories to exclude from auto-calculation
        const excludedCategories = [
            'Quest', 'Syndicate', 'Component', 'Other', 
            'Decoration', 'Cosmetic', 'Railjack', 'Crafting', 'Gear'
        ];
        
        // Data for blueprint source options
        const blueprintSourceOptions = {
            "Quest": [
                "Awakening", "Vor's Prize", "Saya's Vigil", "Vox Solaris", "Once Awake", "Heart of Deimos", "The Archwing", "Natah", "The Second Dream", "Rising Tide", "The War Within", "Chains of Harrow", "Apostasy Prologue", "The Sacrifice", "Prelude to War", "The New War", "The Duviri Paradox", "Angels of the Zariman", "Whispers in the Walls", "The Lotus Eaters", "Jade Shadows", "The Hex", "Howl of the Kubrow", "Stolen Dreams", "Veilbreaker", "Patient Zero", "A Man of Few Words", "The Deadlock Protocol", "Call of the Tempestarii", "The New Strange", "The Glast Gambit", "Octavia's Anthem", "Sands of Inaros", "Hidden Messages", "Mask of the Revenant", "The Silver Grove", "The Waverider", "The Limbo Theorem", "The Jordas Precept"
            ],
            "Lab": [
                "Bio Lab", "Chem Lab", "Energy Lab", "Tenno Lab", "Orokin Lab", "Ventkids' Bash Lab", "Dry Dock", "Dagath's Hollow"
            ],
            "Syndicate": [
                "Steel Meridian", "Arbiters of Hexis", "Cephalon Suda", "The Perrin Sequence", "Red Veil", "New Loka", "Conclave", "Cephalon Simaris", "Ostoron", "The Quills", "Solaris United", "Vox Solaris", "Ventkids", "Entrati", "Necraloid", "The Holdfasts", "Cavia", "The Hex", "Operational Supply", "Nightwave"
            ],
            "Boss": [
                "Captain Vor", "Councilor Vay Hek", "Lieutenant Lech Kril", "General Sargas Ruk", "Tyl Regor", "Kela De Thaym", "Balor Fomorian", "Jackal", "The Sergeant", "Alad V", "Raptors", "Hyena Pack", "Ambulas", "Razorback", "Phorid", "Lephantis", "Juggernaut Behemoth", "Jordas Golem", "Mutalist Alad V", "Hemocyte", "Zealoid Prelate", "Ropalolyst", "Nihil", "The Fragmented", "Ven'kra Tel", "Sprag", "Lynx", "Juggernaut", "Corrupted Vor", "Leekter", "Shik Tal", "Vem Tabook", "John Prodman", "Misery", "Angst", "Malice", "Mania", "Torment", "Violence", "H-09 Apex", "Eidolon Teralyst", "Eidolon Gantulyst", "Eidolon Hydrolyst", "Profit-Taker Orb", "Exploiter Orb", "Orowyrm", "Kuva Lich", "Sister of Parvos"
            ],
            "Mission": {
                "Type": [
                    "Alchemy", "Arena", "Ascension", "Assassination", "Assault", "Capture", "Defection", "Defense", "Mirror Defense", "Disruption", "Excavation", "Exterminate", "Free Roam", "Heist", "Isolation Vault", "Hijack", "Infested Salvage", "Interception", "Junction", "Mobile Defense", "Netracells", "Orphix", "Pursuit", "Rescue", "Rush", "Sabotage", "Sanctuary Onslaught", "Skirmish", "Shrine Defense", "Spy", "Survival", "Void Armageddon", "Void Cascade", "Void Flood", "Volatile", "Faceoff", "Legacyte Harvest", "Hell-Scrub"
                ],
                "Location": [
                    "Mercury", "Venus", "Earth", "Lua", "Mars", "Deimos", "Phobos", "Ceres", "Jupiter",
                    "Europa", "Saturn", "Uranus", "Neptune", "Pluto", "Sedna", "Eris", "Kuva Fortress",
                    "Void", "Zariman", "Albrecht's Laboratories", "Earth Proxima", "Saturn Proxima", "Venus Proxima", "Neptune Proxima", "Pluto Proxima", "Veil Proxima", "Plains of Eidolon", "Orb Vallis", "Cambion Drift", "Duviri", "Höllvania"
                ]
            },
            "Junction": [
                "Mercury Junction", "Venus Junction", "Mars Junction", "Phobos Junction",
                "Ceres Junction", "Jupiter Junction", "Europa Junction", "Saturn Junction", "Uranus Junction",
                "Neptune Junction", "Pluto Junction", "Sedna Junction", "Eris Junction"
            ],
            "Bounty": {
                "Location": [
                    "Plains of Eidolon - Field Bounties", "Plains of Eidolon - Ghoul Purge Bounties", "Plains of Eidolon - Eidolon Hunt Bounties", "Orb Vallis - Field Bounties", "Orb Vallis - Profit-Taker Bounties", "Orb Vallis - Exploiter Bounties", "Cambion Drift - Field Bounties", "Cambion Drift - Isolation Vault", "Cambion Drift - Arcana Bounties", "Zariman Ten Zero - Mission Bounties", "Albrecht's Laboratories - Mission Bounties", "Höllvania - Mission Bounties"
                ],
                "Type": [
                    "Tier 1", "Tier 2", "Tier 3", "Tier 4", "Tier 5", "Tier 6", "Steel Path", "Narmer", "Phase 1", "Phase 2", "Phase 3", "Phase 4"
                ]
            },
            "Assassin": [
                "Stalker", "Shadow Stalker", "Zanuka Hunter", "The Gustrag Three", "Wolf of Saturn Six"
            ],
            "Relic": {
                "Tier": [
                    "Lith", "Meso", "Neo", "Axi", "Requiem"
                ],
                "Rarity": [
                    "Common", "Uncommon", "Rare"
                ]
            }
        };
        
        // Initialize application
        document.addEventListener('DOMContentLoaded', function() {
            // Load data from localStorage
            loadDataFromStorage();
            
            // Initialize tabs
            initializeTabs();
            
            // Initialize resource manager
            initializeResourceManager();
            
            // Initialize item manager
            initializeItemManager();
            
            // Initialize syndicate manager
            initializeSyndicateManager();
            
            // Initialize inventory tracker
            initializeInventory();
            
            // Initialize calculator
            initializeCalculator();
            
            // Initialize mastery tracker
            initializeMasteryTracker();
            
            // Initialize blueprint source components
            initializeBlueprintSourceUI();
            
            // Add sorting buttons
            initializeSortButtons();
            
            // Fix import buttons
            fixImportFunctions();
            
            // Update mastery count on initial load
            setTimeout(updateMasteryCount, 500);
            
            // When items are added or changed, update the resource selects
            document.addEventListener('itemsChanged', function() {
                populateResourceAndItemSelects();
            });
        });
        // Add a rebuild function that runs when Inventory tab is activated
document.addEventListener('inventoryTabActivated', function() {
    console.log("Inventory tab activated - full rebuild of filtering");
    
    // Give the DOM time to settle
    setTimeout(() => {
        initializeLocationTabs();
        initializeItemCategoryTabs();
        fixTabStyles();
        
        // Force a complete rebuild of the filtering
        rebuildItemFiltering();
    }, 500);
});


        
// Load data from storage
async function loadDataFromStorage() {
    // First, load any existing inventory data from localStorage to preserve user progress
    const localInventory = JSON.parse(localStorage.getItem('warframeInventory') || '{"credits":0,"resources":{},"masteredItems":{},"items":{},"blueprints":{}}');
    
    // Ensure inventory has all required properties
    if (!localInventory.masteredItems) localInventory.masteredItems = {};
    if (!localInventory.items) localInventory.items = {};
    if (!localInventory.blueprints) localInventory.blueprints = {};
    

    
    // GitHub repository information
    const githubUser = 'Zurix789';
    const githubRepo = 'warframe-calculator';
    const githubBranch = 'main';
    
    // Define GitHub raw file URLs
    const resourcesUrl = `https://raw.githubusercontent.com/${githubUser}/${githubRepo}/${githubBranch}/warframe_resources.json`;
    const itemsUrl = `https://raw.githubusercontent.com/${githubUser}/${githubRepo}/${githubBranch}/warframe_items.json`;
    
    try {
        // Load resources from GitHub
        console.log(`Fetching resources from: ${resourcesUrl}`);
        const resourcesResponse = await fetch(resourcesUrl);
        if (!resourcesResponse.ok) {
            throw new Error(`Failed to fetch resources: ${resourcesResponse.status} ${resourcesResponse.statusText}`);
        }
        
        // Load items from GitHub
        console.log(`Fetching items from: ${itemsUrl}`);
        const itemsResponse = await fetch(itemsUrl);
        if (!itemsResponse.ok) {
            throw new Error(`Failed to fetch items: ${itemsResponse.status} ${itemsResponse.statusText}`);
        }
        
        // Parse JSON responses
        const githubResources = await resourcesResponse.json();
        const githubItems = await itemsResponse.json();
        
        console.log(`Successfully loaded ${githubResources.length} resources and ${githubItems.length} items from GitHub`);
        
        // Use GitHub data for resources and items
        resources = githubResources;
        items = githubItems;
        
        // Preserve inventory quantities for existing resources
        resources.forEach(resource => {
            if (resource.name) {
                // Initialize with existing quantity or 0
                inventory.resources[resource.name] = localInventory.resources[resource.name] || 0;
            }
        });
        
        // Process items and preserve user data
        items.forEach(item => {
            if (!item.name) return;
            
            // Ensure resources array has type property for backward compatibility
            if (item.resources && Array.isArray(item.resources)) {
                item.resources = item.resources.map(resource => {
                    if (!resource.type) {
                        return { ...resource, type: 'resource' };
                    }
                    return resource;
                });
            }
            
            // Migrate old blueprint source format to new format if necessary
            if (item.blueprintSource && !item.blueprintSources) {
                item.blueprintSources = [{
                    type: item.blueprintSource,
                    details: {}
                }];
            }
            
            // Set default mastery status if not present
            if (typeof item.mastered !== 'boolean') {
                item.mastered = false;
            }
            
            // Set providesMastery if not present
            if (typeof item.providesMastery !== 'boolean') {
                // Determine based on category
                item.providesMastery = !excludedCategories.includes(item.category);
            }
            
            // Preserve user's mastery status from local inventory
            if (typeof localInventory.masteredItems[item.name] === 'boolean') {
                // Use inventory mastery status as the source of truth
                item.mastered = localInventory.masteredItems[item.name];
                inventory.masteredItems[item.name] = item.mastered;
            } else {
                // Default to not mastered if no local status
                inventory.masteredItems[item.name] = item.mastered;
            }
            
            // Preserve item inventory quantities
            inventory.items[item.name] = localInventory.items[item.name] || 0;
            inventory.blueprints[item.name] = localInventory.blueprints[item.name] || 0;
        });
        
        // Preserve credits amount
        inventory.credits = localInventory.credits || 0;
        
        // Load syndicates from localStorage (we don't have GitHub data for these)
        syndicates = JSON.parse(localStorage.getItem('warframeSyndicates') || '[]');
        
        // Save the synchronized data to localStorage as a backup
        saveInventory();
        

        
        return true;
    } catch (error) {
        console.error('Error loading data from GitHub:', error);
        showNotification(`Error loading from GitHub: ${error.message}. Falling back to local data.`, 5000, 'error');
        
        // Fall back to local storage data if GitHub fetch fails
        resources = JSON.parse(localStorage.getItem('warframeResources') || '[]');
        items = JSON.parse(localStorage.getItem('warframeItems') || '[]');
        syndicates = JSON.parse(localStorage.getItem('warframeSyndicates') || '[]');
        inventory = localInventory;
        
        return false;
    }
}

// Step 2: Modify the initialization function to call the async loadDataFromStorage
// Find the document.addEventListener('DOMContentLoaded', function() { ... }) section
// and update it to handle the async loadDataFromStorage function:

// Modified document.addEventListener function
document.addEventListener('DOMContentLoaded', async function() {
    try {
        // Load data from GitHub asynchronously
        await loadDataFromStorage();
        
        // Initialize tabs
        initializeTabs();
        
        // Initialize resource manager
        initializeResourceManager();
        
        // Initialize item manager
        initializeItemManager();
        
        // Initialize syndicate manager
        initializeSyndicateManager();
        
        // Initialize inventory tracker
        initializeInventory();
        
        // Initialize calculator
        initializeCalculator();
        
        // Initialize mastery tracker
        initializeMasteryTracker();
        
        // Initialize blueprint source components
        initializeBlueprintSourceUI();
        
        // Add sorting buttons
        initializeSortButtons();
        
        // Fix import buttons
        fixImportFunctions();
        
        // Update mastery count on initial load
        setTimeout(updateMasteryCount, 500);
        
        // When items are added or changed, update the resource selects
        document.addEventListener('itemsChanged', function() {
            populateResourceAndItemSelects();
        });
    } catch (error) {
        console.error("Error during initialization:", error);
        showNotification("Error initializing application. Check console for details.", 5000, 'error');
    }
});
        document.addEventListener('DOMContentLoaded', function() {
    // Your existing initialization code...
    
    // Fix tab styles
    fixTabStyles();
    
    // Additional initialization for inventory tab
    document.addEventListener('inventoryTabActivated', function() {
        console.log("Inventory tab activated event triggered");
        setTimeout(() => {
            initializeLocationTabs(true);
            initializeItemCategoryTabs();
            fixTabStyles();
        }, 100);
    });
});
        // Add this to your document ready function or initialization code
document.addEventListener('DOMContentLoaded', function() {
    // Existing initialization code...
    
    // Fix tab styles and initialize tabs
    fixTabStyles();
    
    // Ensure inventory tab has special initialization
    document.addEventListener('inventoryTabActivated', function() {
        console.log("Inventory tab activated - initializing filtering systems");
        
        // Wait a bit for the DOM to settle
        setTimeout(() => {
            if (!window.locationTabsInitialized) {
                initializeLocationTabs();
            }
            
            if (!window.itemTabsInitialized) {
                initializeItemCategoryTabs();
            }
            
            fixTabStyles();
            
            // Force filter application
            if (typeof applyItemFilters === 'function') {
                applyItemFilters();
            }
        }, 300); // Slightly longer timeout for stability
    });
    
    // Also initialize the tabs if the inventory tab is active by default
    if (document.querySelector('.tab[data-tab="inventory"]').classList.contains('active')) {
        console.log("Inventory tab is active by default - initializing");
        setTimeout(() => {
            initializeLocationTabs();
            initializeItemCategoryTabs();
            fixTabStyles();
        }, 300);
    }
});
        // Tab functionality
// Tab functionality with location tabs support
function initializeTabs() {
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    
    tabs.forEach(tab => {
        tab.addEventListener('click', () => {
            // Remove active class from all tabs and contents
            tabs.forEach(t => t.classList.remove('active'));
            tabContents.forEach(content => content.classList.remove('active'));
            
            // Add active class to clicked tab and corresponding content
            tab.classList.add('active');
            const tabName = tab.getAttribute('data-tab');
            document.getElementById(tabName).classList.add('active');
            
            // Special handling for each tab
            switch(tabName) {
                case 'inventory':
                    renderInventory();
                    
                    // Force re-initialization of both tab systems
                    console.log("Inventory tab activated - initializing tab systems");
                    setTimeout(() => {
                        // Initialize tabs with force flag to ensure they're properly set up
                        initializeLocationTabs(true);
                        initializeItemCategoryTabs();
                    }, 100);
                    break;
                // Other tab cases remain unchanged
                case 'syndicates':
                    renderSyndicates();
                    break;
                case 'calculator':
                    renderAvailableItems();
                    renderSelectedItems();
                    calculateTotals();
                    updateMasteryCount();
                    break;
                case 'items':
                    populateResourceAndItemSelects();
                    break;
                case 'mastery':
                    renderMasteryItems();
                    updateMasteryProgress();
                    break;
            }
            
            // Trigger a custom event for the activated tab
            document.dispatchEvent(new CustomEvent(tabName + 'TabActivated'));
        });
    });
    
    // Initial setup - if Inventory tab is active by default
    if (document.querySelector('.tab[data-tab="inventory"]').classList.contains('active')) {
        console.log("Inventory tab is active by default");
        setTimeout(() => {
            initializeLocationTabs(true);
            initializeItemCategoryTabs();
        }, 100);
    }
}

// New function to initialize location tabs
function initializeLocationTabs(force = false) {
    // Check if already initialized and not forced to reinitialize
    if (window.locationTabsInitialized && !force) {
        console.log("Location tabs already initialized, skipping");
        return;
    }
    
    console.log("Initializing location tabs");
    
    // Add click handlers to the location tabs
    document.querySelectorAll('.location-tab').forEach(tab => {
        // Remove existing event listeners first if forcing reinitialization
        if (force) {
            const newTab = tab.cloneNode(true);
            tab.parentNode.replaceChild(newTab, tab);
            tab = newTab;
        }
        
        tab.addEventListener('click', function() {
            // Update active state for all tabs
            document.querySelectorAll('.location-tab').forEach(t => {
                t.classList.remove('active');
                t.style.backgroundColor = '#e0e0e0';
                t.style.color = '#333';
            });
            
            // Set this tab as active
            this.classList.add('active');
            this.style.backgroundColor = '#4a7de9';
            this.style.color = 'white';
            
            // Filter resources by location
            filterResourcesByLocation(this.getAttribute('data-location'));
        });
    });
    
    // Mark as initialized
    window.locationTabsInitialized = true;
    
    // Also need to integrate with search functionality
    enhanceSearchWithLocationFilter();
}

// Enhance search to work alongside location filtering
function enhanceSearchWithLocationFilter() {
    const originalFilterFn = window.filterInventoryResources;
    
    if (originalFilterFn) {
        // Override the original function to maintain location filtering
        window.filterInventoryResources = function() {
            // Call the original search filter first
            originalFilterFn();
            
            // Then reapply location filtering if active
            const activeLocationTab = document.querySelector('.location-tab.active');
            if (activeLocationTab && activeLocationTab.getAttribute('data-location') !== 'All') {
                filterResourcesByLocation(activeLocationTab.getAttribute('data-location'));
            }
        };
    }
}

// Make sure the renderInventory function preserves location filtering
// Diagnostic function to check what's in the items array
function diagnoseItemsData() {
    console.log("------ ITEM DATA DIAGNOSTICS ------");
    console.log(`Total items in data: ${items.length}`);
    
    // Check for Warframes specifically
    const warframes = items.filter(item => 
        item.category === 'Warframes' || 
        item.category === 'Warframe' || 
        item.name.includes('Warframe') ||
        (item.description && item.description.includes('Warframe'))
    );
    
    console.log(`Warframes found in data: ${warframes.length}`);
    if (warframes.length > 0) {
        console.log("Sample Warframes:");
        warframes.slice(0, 3).forEach(wf => {
            console.log(`- ${wf.name} (Category: ${wf.category})`);
        });
    }
    
    // Count items by category
    const categories = {};
    items.forEach(item => {
        if (!item.category) {
            if (!categories['Uncategorized']) categories['Uncategorized'] = 0;
            categories['Uncategorized']++;
            return;
        }
        
        if (!categories[item.category]) categories[item.category] = 0;
        categories[item.category]++;
    });
    
    console.log("Items by category:");
    Object.entries(categories)
        .sort((a, b) => b[1] - a[1]) // Sort by count descending
        .forEach(([category, count]) => {
            console.log(`- ${category}: ${count}`);
        });
        
    // Check DOM for Warframe elements
    const itemCards = document.querySelectorAll('#item-inventory .inventory-resource-card');
    let warframeElementsFound = 0;
    
    itemCards.forEach(card => {
        const nameEl = card.querySelector('.resource-name');
        if (!nameEl) return;
        
        const fullText = nameEl.textContent;
        const itemName = fullText.split(/\s+/)[0]; // Get first word
        
        const item = items.find(i => i.name === itemName);
        if (item && (item.category === 'Warframes' || item.category === 'Warframe')) {
            warframeElementsFound++;
            console.log(`Warframe element found: ${itemName} (Display: ${card.style.display})`);
        }
    });
    
    console.log(`Warframe elements in DOM: ${warframeElementsFound}`);
    console.log("------ END DIAGNOSTICS ------");
}

// Complete replacement for renderInventory function focusing on item rendering
function renderInventory() {
    console.log("Rendering inventory...");
    
    // Store active filters
    const activeLocationTab = document.querySelector('.location-tab.active');
    const activeLocation = activeLocationTab ? activeLocationTab.getAttribute('data-location') : 'All';
    
    const resourceInventoryElement = document.getElementById('resource-inventory');
    const itemInventoryElement = document.getElementById('item-inventory');
    
    if (!resourceInventoryElement || !itemInventoryElement) {
        console.error("Missing inventory elements!");
        return;
    }
    
    // Resources rendering (kept simple for now)
    if (resources.length === 0) {
        resourceInventoryElement.innerHTML = '<div class="empty-message">No resources available. Add resources in the Resource Manager tab first.</div>';
    } else {
        resourceInventoryElement.innerHTML = '';
        
        // Get search term if available
        const searchInput = document.getElementById('inventory-search');
        const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
        
        // Filter resources by search term
        const filteredResources = resources.filter(resource => 
            !searchTerm || resource.name.toLowerCase().includes(searchTerm)
        );
        
        if (filteredResources.length === 0) {
            resourceInventoryElement.innerHTML = '<div class="empty-message">No matching resources found</div>';
        } else {
            filteredResources.forEach(resource => {
                const resourceElement = document.createElement('div');
                resourceElement.className = 'inventory-resource-card';
                
                // Get current quantity from inventory
                const currentQuantity = inventory.resources[resource.name] || 0;
                
                resourceElement.innerHTML = `
                    <div class="inventory-resource-info">
                        <div class="resource-img">
                            ${resource.image ? `<img src="${resource.image}" alt="${resource.name}" onerror="this.onerror=null; this.src='https://via.placeholder.com/36?text=📦'; this.style.opacity=0.5;">` : '<span>📦</span>'}
                        </div>
                        <div>
                            <div class="resource-name">${resource.name}</div>
                            <div class="resource-rarity">${resource.rarity}</div>
                        </div>
                    </div>
                    <div class="inventory-quantity-control">
                        <input 
                            type="number" 
                            class="inventory-quantity-input" 
                            value="${currentQuantity}" 
                            min="0" 
                            data-resource="${resource.name}" 
                            onchange="updateResourceQuantity(this)"
                        >
                        <button class="btn" onclick="updateResourceQuantity(this.previousElementSibling)">Save</button>
                    </div>
                `;
                
                resourceInventoryElement.appendChild(resourceElement);
            });
        }
    }
    
    // Improved item inventory rendering with detailed logging
    if (items.length === 0) {
        itemInventoryElement.innerHTML = '<div class="empty-message">No items available. Add items in the Item Manager tab first.</div>';
        console.log("No items to render");
    } else {
        console.log(`Rendering ${items.length} items`);
        itemInventoryElement.innerHTML = '';
        
        // Get search term if available
        const searchInput = document.getElementById('inventory-items-search');
        const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
        
        // Filter items by search term but don't apply category filtering yet
        let filteredItems = items;
        if (searchTerm) {
            filteredItems = items.filter(item => 
                item.name.toLowerCase().includes(searchTerm)
            );
            console.log(`Search filtered to ${filteredItems.length} items`);
        }
        
        if (filteredItems.length === 0) {
            itemInventoryElement.innerHTML = '<div class="empty-message">No matching items found</div>';
        } else {
            // Count items by category for debugging
            const categoryCount = {};
            filteredItems.forEach(item => {
                const cat = item.category || 'Uncategorized';
                if (!categoryCount[cat]) categoryCount[cat] = 0;
                categoryCount[cat]++;
            });
            
            console.log("Items by category to render:");
            Object.entries(categoryCount).forEach(([cat, count]) => {
                console.log(`- ${cat}: ${count}`);
            });
            
            // Render each item
            filteredItems.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'inventory-resource-card';
                itemElement.setAttribute('data-category', item.category || 'Uncategorized');
                
                // Get current quantity from inventory
                const currentQuantity = inventory.items[item.name] || 0;
                
                // Get blueprint quantity from inventory
                const blueprintQuantity = inventory.blueprints[item.name] || 0;
                
                // Get mastery status
                const isMastered = inventory.masteredItems[item.name] || false;
                const providesMastery = item.providesMastery || false;
                
                let masteryHTML = '';
                if (providesMastery) {
                    masteryHTML = `
                        <span class="mastery-indicator" style="margin-left: 5px; font-size: 12px; padding: 2px 6px; 
                            border-radius: 10px; cursor: pointer; background-color: ${isMastered ? '#28a745' : '#dc3545'}; color: white;"
                            onclick="toggleMastery('${item.name.replace(/'/g, "\\'")}', this)">
                            ${isMastered ? 'Mastered' : 'Unmastered'}
                        </span>
                    `;
                }
                
                // Determine if the item has an infinite-use blueprint
                const hasInfiniteBlueprint = item.infiniteUses;
                const blueprintInput = hasInfiniteBlueprint ? 
                    `<div class="blueprint-checkbox">
                        <input type="checkbox" id="bp-${item.name.replace(/\s+/g, '-')}" 
                            ${blueprintQuantity > 0 ? 'checked' : ''} 
                            onchange="updateBlueprintStatus('${item.name.replace(/'/g, "\\'")}', this.checked)">
                        <label for="bp-${item.name.replace(/\s+/g, '-')}">Have Blueprint</label>
                    </div>` : 
                    `<div class="blueprint-input">
                        <label for="bp-qty-${item.name.replace(/\s+/g, '-')}">Blueprints:</label>
                        <input type="number" 
                            id="bp-qty-${item.name.replace(/\s+/g, '-')}" 
                            class="blueprint-quantity-input" 
                            value="${blueprintQuantity}" 
                            min="0" 
                            data-item="${item.name}" 
                            onchange="updateBlueprintQuantity(this)">
                    </div>`;
                
                itemElement.innerHTML = `
                    <div class="inventory-resource-info">
                        <div class="resource-img">
                            ${item.image ? `<img src="${item.image}" alt="${item.name}" onerror="this.onerror=null; this.src='https://via.placeholder.com/36?text=🔨'; this.style.opacity=0.5;">` : '<span>🔨</span>'}
                        </div>
                        <div>
                            <div class="resource-name">${item.name} ${masteryHTML}</div>
                            <div class="resource-rarity">${item.category || 'Uncategorized'}</div>
                            ${blueprintInput}
                        </div>
                    </div>
                    <div class="inventory-quantity-control">
                        <input 
                            type="number" 
                            class="inventory-quantity-input" 
                            value="${currentQuantity}" 
                            min="0" 
                            data-item="${item.name}" 
                            onchange="updateInventoryItemQuantity(this)"
                        >
                        <button class="btn" onclick="updateInventoryItemQuantity(this.previousElementSibling)">Save</button>
                    </div>
                `;
                
                itemInventoryElement.appendChild(itemElement);
            });
            
            console.log(`Rendered ${filteredItems.length} item cards`);
        }
    }
    
    // Run diagnostics to check for issues
    setTimeout(diagnoseItemsData, 500);
    
    // Reapply location filtering after rendering if not "All"
    if (activeLocation !== 'All') {
        setTimeout(() => {
            filterResourcesByLocation(activeLocation);
        }, 0);
    }
    
    // Don't reapply item category filtering here - we'll do it separately
}

// Start with a clean slate approach to filtering
function rebuildItemFiltering() {
    console.log("Rebuilding item filtering system");
    
    // Clear any existing filters first
    document.querySelectorAll('#item-inventory .inventory-resource-card').forEach(card => {
        card.style.display = ''; // Show all cards
    });
    
    // Log what we have to filter
    const itemCards = document.querySelectorAll('#item-inventory .inventory-resource-card');
    console.log(`Found ${itemCards.length} item cards for filtering`);
    
    // Check if all items are visible at this point
    const warframeCount = Array.from(itemCards).filter(card => {
        const categoryEl = card.querySelector('.resource-rarity');
        return categoryEl && (categoryEl.textContent === 'Warframes' || categoryEl.textContent === 'Warframe');
    }).length;
    
    console.log(`Warframe cards found: ${warframeCount}`);
    
    // Now apply the actual filtering based on currently selected category
    applyItemFilters();
}
        
        // Save functions
        function saveResources() {
            localStorage.setItem('warframeResources', JSON.stringify(resources));
            showSaveNotification();
            renderInventory();
        }
        
        function saveItems() {
            localStorage.setItem('warframeItems', JSON.stringify(items));
            showSaveNotification();
            
            document.dispatchEvent(new CustomEvent('itemsChanged'));
        }
        
        function saveSyndicates() {
            localStorage.setItem('warframeSyndicates', JSON.stringify(syndicates));
            showSaveNotification();
        }
        
        function saveInventory() {
            localStorage.setItem('warframeInventory', JSON.stringify(inventory));
            showSaveNotification();
        }
        function showNotification(message, duration = 2000) {
    const notification = document.getElementById('saveNotification');
    if (!notification) return;
    
    notification.textContent = message;
    notification.classList.add('show');
    
    setTimeout(() => {
        notification.classList.remove('show');
    }, duration);
}

// Replace all instances of the original showSaveNotification with this
function showSaveNotification(message = 'Data saved successfully!') {
    showNotification(message);
}
        function showSaveNotification() {
            const notification = document.getElementById('saveNotification');
            notification.classList.add('show');
            
            setTimeout(() => {
                notification.classList.remove('show');
            }, 1);
        }
        
        // Export data to JSON file
        function exportToJson(data, filename) {
            const jsonStr = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            
            URL.revokeObjectURL(url);
        }
        
        // Import functions (consolidated)
        function fixImportFunctions() {
            // Fix resource import
            const importResourcesBtn = document.getElementById('importResourcesBtn');
            const resourcesFileInput = document.getElementById('resourcesFileInput');
            
            if (importResourcesBtn && resourcesFileInput) {
                importResourcesBtn.addEventListener('click', function() {
                    resourcesFileInput.click();
                });
                
                resourcesFileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedResources = JSON.parse(e.target.result);
                            
                            if (!Array.isArray(importedResources)) {
                                throw new Error('Invalid resource data format. Expected an array.');
                            }
                            
                            if (confirm(`Are you sure you want to import ${importedResources.length} resources? This will not replace your existing resources - they will be added to your collection.`)) {
                                // Check for duplicates
                                const existingNames = resources.map(r => r.name);
                                const newResources = [];
                                const duplicates = [];
                                
                                importedResources.forEach(resource => {
                                    if (!resource.name) return; // Skip invalid resources
                                    
                                    if (existingNames.includes(resource.name)) {
                                        duplicates.push(resource.name);
                                    } else {
                                        existingNames.push(resource.name);
                                        newResources.push(resource);
                                    }
                                });
                                
                                // Add new resources
                                resources = resources.concat(newResources);
                                saveResources();
                                renderResources();
                                populateResourceAndItemSelects();
                                
                                // Also reinitialize the resource selection for items
                                setTimeout(() => {
                                    reinitializeResourceSelection();
                                }, 100);
                                
                                // Show results
                                if (duplicates.length > 0) {
                                    alert(`Import complete!\nAdded ${newResources.length} new resources.\nSkipped ${duplicates.length} duplicates.`);
                                } else {
                                    alert(`Import complete! Added ${newResources.length} new resources.`);
                                }
                            }
                        } catch (error) {
                            alert('Error importing resources: ' + error.message);
                            console.error('Import error:', error);
                        }
                        
                        // Reset file input
                        resourcesFileInput.value = '';
                    };
                    
                    reader.readAsText(file);
                });
            }
            
            // Fix item import
            const importItemsBtn = document.getElementById('importItemsBtn');
            const itemsFileInput = document.getElementById('itemsFileInput');
            
            if (importItemsBtn && itemsFileInput) {
                importItemsBtn.addEventListener('click', function() {
                    itemsFileInput.click();
                });
                
                itemsFileInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedItems = JSON.parse(e.target.result);
                            
                            if (!Array.isArray(importedItems)) {
                                throw new Error('Invalid item data format. Expected an array.');
                            }
                            
                            if (confirm(`Are you sure you want to import ${importedItems.length} items? This will not replace your existing items - they will be added to your collection.`)) {
                                // Check for duplicates
                                const existingNames = items.map(i => i.name);
                                const newItems = [];
                                const duplicates = [];
                                
                                importedItems.forEach(item => {
                                    if (!item.name) return;
                                    
                                    if (existingNames.includes(item.name)) {
                                        duplicates.push(item.name);
                                    } else {
                                        existingNames.push(item.name);
                                        
                                        // Ensure resources array has type property for backward compatibility
                                        if (item.resources && Array.isArray(item.resources)) {
                                            item.resources = item.resources.map(resource => {
                                                if (!resource.type) {
                                                    return { ...resource, type: 'resource' };
                                                }
                                                return resource;
                                            });
                                        }
                                        
                                        // Migrate old blueprint source format to new format if necessary
                                        if (item.blueprintSource && !item.blueprintSources) {
                                            item.blueprintSources = [{
                                                type: item.blueprintSource,
                                                details: {}
                                            }];
                                        }
                                        
                                        // Set default mastery status if not present
                                        if (typeof item.mastered !== 'boolean') {
                                            item.mastered = false;
                                        }
                                        
                                        // Set providesMastery if not present
                                        if (typeof item.providesMastery !== 'boolean') {
                                            // Determine based on category
                                            item.providesMastery = !excludedCategories.includes(item.category);
                                        }
                                        
                                        newItems.push(item);
                                        
                                        // Update inventory mastery status
                                        inventory.masteredItems[item.name] = item.mastered;
                                    }
                                });
                                
                                // Add new items
                                items = items.concat(newItems);
                                
                                // Save with enhanced function to refresh UI
                                saveItemsAndRefreshUI();
                                saveInventory();
                                
                                // Show results
                                if (duplicates.length > 0) {
                                    alert(`Import complete!\nAdded ${newItems.length} new items.\nSkipped ${duplicates.length} duplicates.`);
                                } else {
                                    alert(`Import complete! Added ${newItems.length} new items.`);
                                }
                            }
                        } catch (error) {
                            alert('Error importing items: ' + error.message);
                            console.error('Import error:', error);
                        }
                        
                        // Reset file input
                        itemsFileInput.value = '';
                    };
                    
                    reader.readAsText(file);
                });
            }
        }
        
        // Enhanced save items function
        function saveItemsAndRefreshUI() {
            // Save items to localStorage
            saveItems();
            
            // Render items table
            renderItems();
            
            // Update resource selects to include new items
            populateResourceAndItemSelects();
            
            // Make sure inventory is updated
            renderInventory();
            
            // Update calculator if open
            if (typeof renderAvailableItems === 'function') {
                renderAvailableItems();
            }
            
            // Reinitialize resource selection if that function exists
            if (typeof reinitializeResourceSelection === 'function') {
                reinitializeResourceSelection();
            }
            
            // Trigger custom event for item changes
            document.dispatchEvent(new CustomEvent('itemsChanged'));
            
            // Show save notification
            showSaveNotification('Items updated successfully!');
        }
        
        /****************************
         * RESOURCE MANAGER SECTION *
         ****************************/
        function initializeResourceManager() {
            // Cache DOM elements
            const resourceNameInput = document.getElementById('resourceName');
            const raritySelect = document.getElementById('rarity');
            const imageUrlInput = document.getElementById('imageUrl');
            const imagePreview = document.getElementById('imagePreview');
            const addResourceBtn = document.getElementById('addResourceBtn');
            const exportResourcesBtn = document.getElementById('exportResourcesBtn');
            const clearResourcesBtn = document.getElementById('clearResourcesBtn');
            
            let editResourceIndex = null;
            
            // Add event listeners
            addResourceBtn.addEventListener('click', function() {
                addResource();
            });
            
            exportResourcesBtn.addEventListener('click', function() {
                exportToJson(resources, 'warframe_resources.json');
            });
            
            clearResourcesBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to delete ALL resources? This cannot be undone.')) {
                    resources = [];
                    saveResources();
                    renderResources();
                    populateResourceAndItemSelects();
                    alert('All resources have been cleared.');
                }
            });
            
            // Add event listener for image URL input to update preview
            imageUrlInput.addEventListener('input', function() {
                updateImagePreview();
            });
            
            // Render resources initially
            renderResources();
            
            // Image preview functionality
            function updateImagePreview() {
                const imageUrl = imageUrlInput.value.trim();
                imagePreview.innerHTML = '';
                
                if (imageUrl) {
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.onerror = function() {
                        this.parentNode.innerHTML = '<span class="no-image">Invalid image URL</span>';
                    };
                    imagePreview.appendChild(img);
                } else {
                    imagePreview.innerHTML = '<span class="no-image">No image URL provided</span>';
                }
            }
            
            // Get selected locations from checkboxes
            function getSelectedLocations() {
                const locationCheckboxes = document.querySelectorAll('#locationsGrid input:checked');
                const locations = [];
                
                for (let i = 0; i < locationCheckboxes.length; i++) {
                    locations.push(locationCheckboxes[i].value);
                }
                
                return locations;
            }
            
            // Clear location checkboxes
            function clearLocations() {
                const locationCheckboxes = document.querySelectorAll('#locationsGrid input');
                
                for (let i = 0; i < locationCheckboxes.length; i++) {
                    locationCheckboxes[i].checked = false;
                }
            }
            
            // Add or update resource
            function addResource() {
                const name = resourceNameInput.value.trim();
                
                if (!name) {
                    alert('Resource name is required!');
                    return;
                }
                
                const resource = {
                    name: name,
                    rarity: raritySelect.value,
                    locations: getSelectedLocations(),
                    image: imageUrlInput.value.trim()
                };
                
                if (editResourceIndex !== null) {
                    resources[editResourceIndex] = resource;
                    editResourceIndex = null;
                    addResourceBtn.textContent = 'Add Resource';
                } else {
                    resources.push(resource);
                }
                
                // Reset form
                resourceNameInput.value = '';
                raritySelect.value = 'Common';
                imageUrlInput.value = '';
                clearLocations();
                imagePreview.innerHTML = '';
                
                // Save and update UI
                saveResources();
                renderResources();
                populateResourceAndItemSelects();
            }
            
            // Render resources table
            function renderResources() {
                const resourcesList = document.getElementById('resourcesList');
                resourcesList.innerHTML = '';
                
                for (let i = 0; i < resources.length; i++) {
                    const resource = resources[i];
                    const row = document.createElement('tr');
                    
                    // Create the image cell
                    const imageCell = document.createElement('td');
                    if (resource.image) {
                        const img = document.createElement('img');
                        img.src = resource.image;
                        img.className = 'resource-image';
                        img.alt = resource.name;
                        img.style.width = '50px';
                        img.style.height = '50px';
                        img.style.objectFit = 'contain';
                        img.onerror = function() {
                            this.src = 'https://via.placeholder.com/50';
                            this.alt = 'Image not found';
                        };
                        imageCell.appendChild(img);
                    } else {
                        imageCell.innerHTML = '<span class="no-image">No image</span>';
                    }
                    
                    row.appendChild(imageCell);
                    
                    // Add the rest of the cells
                    row.innerHTML += 
                        '<td>' + resource.name + '</td>' +
                        '<td>' + resource.rarity + '</td>' +
                        '<td>' + resource.locations.join(', ') + '</td>' +
                        '<td>' +
                            '<div class="action-btns">' +
                                '<button class="btn edit-btn" data-index="' + i + '">Edit</button>' +
                                '<button class="btn btn-red delete-btn" data-index="' + i + '">Delete</button>' +
                            '</div>' +
                        '</td>';
                    
                    bindResourceRowEvents(row, i);
                    resourcesList.appendChild(row);
                }
            }
            
            // Bind events to resource row buttons
            function bindResourceRowEvents(row, index) {
                const editBtn = row.querySelector('.edit-btn');
                const deleteBtn = row.querySelector('.delete-btn');
                
                editBtn.addEventListener('click', function() {
                    editResource(index);
                });
                
                deleteBtn.addEventListener('click', function() {
                    deleteResource(index);
                });
            }
            
            // Edit resource
            function editResource(index) {
                const resource = resources[index];
                
                resourceNameInput.value = resource.name;
                raritySelect.value = resource.rarity;
                imageUrlInput.value = resource.image || '';
                updateImagePreview();
                
                clearLocations();
                for (let i = 0; i < resource.locations.length; i++) {
                    const checkbox = document.querySelector('#locationsGrid input[value="' + resource.locations[i] + '"]');
                    if (checkbox) checkbox.checked = true;
                }
                
                editResourceIndex = index;
                addResourceBtn.textContent = 'Update Resource';
            }
            
            // Delete resource
            function deleteResource(index) {
                if (confirm('Are you sure you want to delete this resource?')) {
                    resources.splice(index, 1);
                    saveResources();
                    renderResources();
                    populateResourceAndItemSelects();
                }
            }
        }
        
        // Resource selection functionality
        function reinitializeResourceSelection() {
            const resourceSelection = document.getElementById('resourceSelection');
            if (!resourceSelection) return;
            
            // Clear existing content
            resourceSelection.innerHTML = '';
            
            // Recreate the resource selection UI from scratch
            const resourceItem = document.createElement('div');
            resourceItem.className = 'resource-item';
            
            const resourceSelect = document.createElement('select');
            resourceSelect.className = 'resourceName';
            resourceSelect.innerHTML = '<option value="">Select Resource or Item</option>';
            
            const quantityInput = document.createElement('input');
            quantityInput.type = 'number';
            quantityInput.className = 'resourceQuantity';
            quantityInput.placeholder = 'Quantity';
            quantityInput.min = '1';
            
            const addButton = document.createElement('button');
            addButton.className = 'addResourceBtn btn';
            addButton.textContent = 'Add Resource';
            
            resourceItem.appendChild(resourceSelect);
            resourceItem.appendChild(quantityInput);
            resourceItem.appendChild(addButton);
            resourceSelection.appendChild(resourceItem);
            
            // Populate the new select with resources and items
            populateResourceAndItemSelects();
        }
        
        // Populate resource and item selects
        function populateResourceAndItemSelects() {
            // Create resource options HTML
            const resourceOptionsHTML = resources.map(resource => {
                const escapedName = resource.name.replace(/"/g, '&quot;');
                return `<option value="resource:${escapedName}">${resource.name} (Resource)</option>`;
            }).join('');
            
            // Create item options HTML
            const itemOptionsHTML = items.map(item => {
                const escapedName = item.name.replace(/"/g, '&quot;');
                return `<option value="item:${escapedName}">${item.name} (Item)</option>`;
            }).join('');
            
            // Apply to all resource selects
            const resourceSelects = document.querySelectorAll('.resourceName, #blueprintCostResource, #rankResourceName');
            
            resourceSelects.forEach(select => {
                // Store the previously selected value if any
                const previousValue = select.value;
                
                // Update the options
                const newOptions = '<option value="">Select Resource or Item</option>' + resourceOptionsHTML + itemOptionsHTML;
                select.innerHTML = newOptions;
                
                // Try to restore previous selection if it exists
                if (previousValue) {
                    select.value = previousValue;
                    
                    // If the exact match wasn't found (e.g., it had no prefix before), try with prefixes
                    if (!select.value && !previousValue.includes(':')) {
                        // Try with resource: prefix
                        select.value = `resource:${previousValue}`;
                        
                        // If still not found, try with item: prefix
                        if (!select.value) {
                            select.value = `item:${previousValue}`;
                        }
                    }
                }
            });
        }
        
        // Get resource icon URL
        function getResourceIcon(resourceName) {
            const resource = resources.find(res => res.name === resourceName);
            return resource && resource.image ? resource.image : '';
        }
        
        /**************************
         * ITEM MANAGER SECTION *
         **************************/
        function initializeItemManager() {
            // Cache DOM elements
            const itemNameInput = document.getElementById('itemName');
            const itemCategorySelect = document.getElementById('itemCategory');
            const itemImageInput = document.getElementById('itemImage');
            const buildCreditCostInput = document.getElementById('buildCreditCost');
            const blueprintCostTypeSelect = document.getElementById('blueprintCostType');
            const blueprintCostResourceSelect = document.getElementById('blueprintCostResource');
            const blueprintCostQuantityInput = document.getElementById('blueprintCostQuantity');
            const resourceSelection = document.getElementById('resourceSelection');
            const addItemBtn = document.getElementById('addItemBtn');
            const exportItemsBtn = document.getElementById('exportItemsBtn');
            const clearItemsBtn = document.getElementById('clearItemsBtn');
            const selectedResourcesList = document.getElementById('selectedResources');
            const refreshResourceBtn = document.getElementById('refreshResourceBtn');
            
            // Reinitialize resource selection on tab load
            reinitializeResourceSelection();
            
            // Populate resource and item selects
            populateResourceAndItemSelects();
            
            // Add event listeners
            if (refreshResourceBtn) {
                refreshResourceBtn.addEventListener('click', function() {
                    reinitializeResourceSelection();
                    alert('Resource selection refreshed!');
                });
            }
            
            addItemBtn.addEventListener('click', function() {
                addItem();
            });
            
            exportItemsBtn.addEventListener('click', function() {
                exportToJson(items, 'warframe_items.json');
            });
            
            clearItemsBtn.addEventListener('click', function() {
                if (confirm('Are you sure you want to delete ALL items? This cannot be undone.')) {
                    items = [];
                    saveItems();
                    renderItems();
                    alert('All items have been cleared.');
                }
            });
            
            // Event delegation for resource selection
            if (resourceSelection) {
                resourceSelection.addEventListener('click', (e) => {
                    if (e.target.classList.contains('addResourceBtn')) {
                        addSelectedResource();
                    }
                });
            }
            
            // Blueprint cost type change
            if (blueprintCostTypeSelect) {
                blueprintCostTypeSelect.addEventListener('change', () => {
                    blueprintCostResourceSelect.classList.toggle(
                        'hidden', 
                        blueprintCostTypeSelect.value !== 'Resource'
                    );
                });
            }
            
            // Event delegation for removing selected resources
            if (selectedResourcesList) {
                selectedResourcesList.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-resource-btn')) {
                        e.target.parentElement.remove();
                    }
                });
            }
            
            // Render items initially
            renderItems();
            
            // Function to add item with blueprint sources
            function addItem() {
                const name = itemNameInput.value.trim();
                
                if (!name) {
                    alert('Item name is required!');
                    return;
                }
                
                // Get blueprint sources
                const blueprintSources = getBlueprintSources();
                
                // Get blueprint status values
                const infiniteUses = document.getElementById('infiniteUses').checked;
                const multiItemBlueprint = document.getElementById('multiItemBlueprint').checked;
                const itemsPerBlueprint = multiItemBlueprint ? 
                    parseInt(document.getElementById('itemsPerBlueprint').value) || 1 : 1;
                
                // Automatically determine if the item provides mastery based on its category
                const category = itemCategorySelect.value;
                const autoProvidesMastery = !excludedCategories.includes(category);
                
                const item = {
                    name: name,
                    category: category,
                    image: itemImageInput.value.trim(),
                    buildCreditCost: buildCreditCostInput.value || 0,
                    blueprintSources: blueprintSources,
                    blueprintCost: {
                        type: blueprintCostTypeSelect.value,
                        resource: blueprintCostTypeSelect.value === 'Resource' ? 
                                blueprintCostResourceSelect.value : '',
                        quantity: blueprintCostQuantityInput.value || 0
                    },
                    resources: getSelectedResources(),
                    infiniteUses: infiniteUses,
                    multiItemBlueprint: multiItemBlueprint,
                    itemsPerBlueprint: itemsPerBlueprint,
                    mastered: false, // Default to false, will be managed in Mastery tab
                    providesMastery: autoProvidesMastery // Automatically set based on category
                };
                
                // By default, items are not mastered in inventory
                inventory.masteredItems[name] = false;
                
                items.push(item);
                resetItemForm();
                saveItems();
                saveInventory();
                renderItems();
            }
            
            // Get selected resources from the list with type information
            function getSelectedResources() {
                const resources = [];
                const items = selectedResourcesList.children;
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    const nameElement = item.querySelector('.resource-name');
                    const name = nameElement.textContent;
                    const type = nameElement.getAttribute('data-type') || 'resource'; // Default to resource for backward compatibility
                    const quantity = item.querySelector('.resource-quantity').textContent;
                    
                    resources.push({ 
                        name: name.trim(), 
                        quantity: parseInt(quantity),
                        type: type
                    });
                }
                
                return resources;
            }
            
            // Add resource to selected resources list
            function addSelectedResource() {
                const resourceNameSelect = resourceSelection.querySelector('.resourceName');
                const resourceQuantityInput = resourceSelection.querySelector('.resourceQuantity');
                
                const selectedValue = resourceNameSelect.value;
                const quantity = resourceQuantityInput.value;
                
                if (selectedValue && quantity) {
                    // Determine if this is a resource or an item
                    const isItem = selectedValue.startsWith('item:');
                    const isResource = selectedValue.startsWith('resource:');
                    
                    let name, type, iconUrl;
                    
                    if (isItem) {
                        name = selectedValue.substring(5); // Remove 'item:' prefix
                        type = 'item';
                        
                        // Check if adding this item would create a circular dependency
                        if (checkCircularDependency(name)) {
                            alert(`Cannot add ${name} as an ingredient as it would create a circular dependency.`);
                            return;
                        }
                        
                        // Get icon from item
                        const item = items.find(i => i.name === name);
                        iconUrl = item && item.image ? item.image : '';
                    } else if (isResource) {
                        name = selectedValue.substring(9); // Remove 'resource:' prefix
                        type = 'resource';
                        iconUrl = getResourceIcon(name);
                    } else {
                        // For backward compatibility
                        name = selectedValue;
                        type = 'resource';
                        iconUrl = getResourceIcon(name);
                    }
                    
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <span class="resource-icon" style="background-image: url(${iconUrl})"></span>
                        <span class="resource-name" data-type="${type}">${name}</span> x 
                        <span class="resource-quantity">${quantity}</span>
                        <button class="btn btn-red remove-resource-btn">Remove</button>
                    `;
                    
                    selectedResourcesList.appendChild(listItem);
                    
                    // Clear inputs for next entry
                    resourceNameSelect.value = '';
                    resourceQuantityInput.value = '';
                }
            }
            
            // Check for circular dependencies
            function checkCircularDependency(itemName) {
                // Get the currently edited item name
                const currentItemName = document.getElementById('itemName').value.trim();
                
                // If we're not editing an existing item, there's no circular dependency risk yet
                if (!currentItemName) return false;
                
                // Check if the item being added as an ingredient depends on the current item
                function dependsOn(checkItem, targetItem, visitedItems = new Set()) {
                    // If we've already visited this item, we might have a cycle
                    if (visitedItems.has(checkItem)) return false;
                    
                    // Add this item to visited set
                    visitedItems.add(checkItem);
                    
                    // Find the item object
                    const item = items.find(i => i.name === checkItem);
                    if (!item || !item.resources) return false;
                    
                    // Check if it directly uses the target item
                    if (item.resources.some(r => r.type === 'item' && r.name === targetItem)) {
                        return true;
                    }
                    
                    // Check if any of its ingredients depend on the target item
                    return item.resources.some(r => 
                        r.type === 'item' && dependsOn(r.name, targetItem, new Set(visitedItems))
                    );
                }
                
                return dependsOn(itemName, currentItemName);
            }
            
            // Reset item form
            function resetItemForm() {
                itemNameInput.value = '';
                itemCategorySelect.value = '';
                itemImageInput.value = '';
                buildCreditCostInput.value = '';
                blueprintCostTypeSelect.value = '';
                blueprintCostResourceSelect.value = '';
                blueprintCostQuantityInput.value = '';
                selectedResourcesList.innerHTML = '';
                
                // Reset blueprint fields
                document.getElementById('infiniteUses').checked = false;
                document.getElementById('multiItemBlueprint').checked = false;
                document.getElementById('itemsPerBlueprint').value = 1;
                document.getElementById('multiItemCountContainer').classList.add('hidden');
                
                // Reset blueprint sources
                setBlueprintSources([]);
            }
            
            // Edit item
            function editItem(index) {
                const item = items[index];
                
                // Populate form with item data
                itemNameInput.value = item.name;
                itemCategorySelect.value = item.category || '';
                itemImageInput.value = item.image || '';
                buildCreditCostInput.value = item.buildCreditCost || 0;
                
                // Set blueprint sources
                if (item.blueprintSources) {
                    setBlueprintSources(item.blueprintSources);
                } else if (item.blueprintSource) {
                    // Legacy support for old single source format
                    setBlueprintSources([{
                        type: item.blueprintSource,
                        details: {}
                    }]);
                } else {
                    setBlueprintSources([]);
                }
                
                blueprintCostTypeSelect.value = item.blueprintCost?.type || '';
                blueprintCostResourceSelect.classList.toggle(
                    'hidden', 
                    item.blueprintCost?.type !== 'Resource'
                );
                blueprintCostResourceSelect.value = item.blueprintCost?.resource || '';
                blueprintCostQuantityInput.value = item.blueprintCost?.quantity || 0;
                
                document.getElementById('infiniteUses').checked = item.infiniteUses || false;
                document.getElementById('multiItemBlueprint').checked = item.multiItemBlueprint || false;
                document.getElementById('itemsPerBlueprint').value = item.itemsPerBlueprint || 1;
                
                toggleMultiItemFields();
                
                // Clear and repopulate selected resources
                selectedResourcesList.innerHTML = '';
                
                if (item.resources && item.resources.length > 0) {
                    item.resources.forEach(resource => {
                        const isItem = resource.type === 'item';
                        let iconUrl;
                        
                        if (isItem) {
                            const ingredientItem = items.find(i => i.name === resource.name);
                            iconUrl = ingredientItem && ingredientItem.image ? ingredientItem.image : '';
                        } else {
                            iconUrl = getResourceIcon(resource.name);
                        }
                        
                        const listItem = document.createElement('li');
                        listItem.innerHTML = `
                            <span class="resource-icon" style="background-image: url(${iconUrl})"></span>
                            <span class="resource-name" data-type="${resource.type || 'resource'}">${resource.name}</span> x 
                            <span class="resource-quantity">${resource.quantity}</span>
                            <button class="btn btn-red remove-resource-btn">Remove</button>
                        `;
                        
                        selectedResourcesList.appendChild(listItem);
                    });
                }
                
                // Remove item from list (will be re-added on save)
                items.splice(index, 1);
                saveItems();
                renderItems();
            }
            
            // Delete item
            function deleteItem(index) {
                if (confirm('Are you sure you want to delete this item?')) {
                    items.splice(index, 1);
                    saveItems();
                    renderItems();
                }
            }
            
            // Render items table
            function renderItems() {
                const itemsList = document.getElementById('itemsList');
                if (!itemsList) return;
                
                itemsList.innerHTML = '';
                
                items.forEach((item, index) => {
                    const row = document.createElement('tr');
                    
                    // Generate resource HTML
                    const resourcesHTML = generateResourceHTML(item);
                    
                    // Generate blueprint cost HTML with new approach
                    let blueprintCostHTML = generateBlueprintCostHTML(item);
                    
                    // Generate blueprint sources HTML
                    let blueprintSourcesHTML = formatDetailedBlueprintSources(item);
                    
                    // Get mastery status
                    const isMastered = inventory.masteredItems[item.name] || false;
                    let masteryHTML = '';
                    
                    if (item.providesMastery) {
                        masteryHTML = isMastered ? 
                            '<span class="mastery-status mastered">Mastered</span>' : 
                            '<span class="mastery-status not-mastered">Not Mastered</span>';
                    } else {
                        masteryHTML = '<span class="mastery-status" style="background-color: #999; color: white;">No Mastery</span>';
                    }
                    
                    // Blueprint status information
                    let blueprintStatusHTML = '';
                    if (item.infiniteUses) {
                        blueprintStatusHTML += '<div style="color: purple; font-size: 12px;">Infinite Uses</div>';
                    }
                    if (item.multiItemBlueprint) {
                        blueprintStatusHTML += `<div style="color: blue; font-size: 12px;">Creates ${item.itemsPerBlueprint} items per blueprint craft</div>`;
                    }
                    
                    row.innerHTML = `
                        <td>${item.image ? `<img src="${item.image}" alt="${item.name}" class="item-image">` : ''}</td>
                        <td>
                            ${item.name}
                            ${masteryHTML}
                        </td>
                        <td>${item.category || 'Uncategorized'}</td>
                        <td class="blueprint-sources-cell">
                            ${blueprintSourcesHTML}
                            ${blueprintStatusHTML}
                        </td>
                        <td>${blueprintCostHTML}</td>
                        <td>${item.buildCreditCost ? `Credits x ${item.buildCreditCost}` : 'N/A'}</td>
                        <td>${resourcesHTML}</td>
                        <td>
                            <div class="action-btns">
                                <button class="btn edit-btn" data-index="${index}">Edit</button>
                                <button class="btn btn-red delete-btn" data-index="${index}">Delete</button>
                            </div>
                        </td>
                    `;
                    
                    bindItemRowEvents(row, index);
                    itemsList.appendChild(row);
                });
            }
            
            // Generate HTML for resources display
            function generateResourceHTML(item) {
                let resourcesHTML = '';
                
                if (item.resources && item.resources.length > 0) {
                    // Create a simple text-based display for resources
                    const resourceDetails = document.createElement('div');
                    resourceDetails.className = 'resource-details-container';
                    
                    item.resources.forEach(resource => {
                        // Determine if this is an item or a resource
                        const isItem = resource.type === 'item';
                        const type = isItem ? 'item' : 'resource';
                        const label = isItem ? '(Item)' : '';
                        
                        // Create simple text display for resources column
                        const detailHtml = `
                            <div class="resource-item-display">
                                <span class="resource-name" style="${isItem ? 'color:#e67e22;' : ''}" 
                                      data-type="${type}">${resource.name}</span> ${label} x ${resource.quantity}
                            </div>
                        `;
                        resourceDetails.innerHTML += detailHtml;
                    });
                    
                    resourcesHTML = resourceDetails.outerHTML;
                } else {
                    resourcesHTML = 'No resources required';
                }
                
                return resourcesHTML;
            }
            
            // Generate HTML for blueprint cost display
            function generateBlueprintCostHTML(item) {
                if (!item.blueprintCost || !item.blueprintCost.type) {
                    return 'N/A';
                }
                
                if (item.blueprintCost.type === "Resource") {
                    // Extract the actual resource name by removing any prefix
                    let resourceName = item.blueprintCost.resource;
                    if (resourceName.startsWith("resource:")) {
                        resourceName = resourceName.substring(9); 
                    } else if (resourceName.startsWith("item:")) {
                        resourceName = resourceName.substring(5);
                    }
                    
                    return `${resourceName} x ${item.blueprintCost.quantity}`;
                } else {
                    return `${item.blueprintCost.type} x ${item.blueprintCost.quantity}`;
                }
            }
            
            // Bind events to item row buttons
            function bindItemRowEvents(row, index) {
                const editBtn = row.querySelector('.edit-btn');
                const deleteBtn = row.querySelector('.delete-btn');
                
                if (editBtn) editBtn.addEventListener('click', () => editItem(index));
                if (deleteBtn) deleteBtn.addEventListener('click', () => deleteItem(index));
            }
        }
        
        // Toggle multi-item blueprint fields visibility
        function toggleMultiItemFields() {
            const multiItemCheckbox = document.getElementById('multiItemBlueprint');
            const multiItemCountContainer = document.getElementById('multiItemCountContainer');
            
            if (multiItemCheckbox && multiItemCountContainer) {
                if (multiItemCheckbox.checked) {
                    multiItemCountContainer.classList.remove('hidden');
                } else {
                    multiItemCountContainer.classList.add('hidden');
                }
            }
        }
        
        /**************************
         * BLUEPRINT SOURCE HANDLERS *
         **************************/
         
        // Initialize blueprint source UI
        function initializeBlueprintSourceUI() {
            // Add event handlers for blueprint sources
            const addSourceBtn = document.getElementById('addBlueprintSourceBtn');
            if (addSourceBtn) {
                addSourceBtn.addEventListener('click', addBlueprintSource);
            }
            
            // Initialize event delegation for source list
            const sourceList = document.getElementById('blueprintSourceList');
            if (sourceList) {
                sourceList.addEventListener('change', handleSourceListChanges);
                sourceList.addEventListener('click', handleSourceListClicks);
            }
            
            // Add the first source entry by default if list is empty
            if (sourceList && sourceList.children.length === 0) {
                addBlueprintSource();
            }
        }
        
        // Add a blueprint source entry
        function addBlueprintSource() {
            const sourceList = document.getElementById('blueprintSourceList');
            const template = document.getElementById('blueprintSourceTemplate');
            
            if (!sourceList || !template) return;
            
            // Clone the template
            const sourceEntry = template.querySelector('.blueprint-source-entry').cloneNode(true);
            sourceList.appendChild(sourceEntry);
        }
        
        // Handle changes to source list (type changes)
        function handleSourceListChanges(event) {
            const target = event.target;
            
            // Check if a source type dropdown was changed
            if (target.classList.contains('blueprintSourceType')) {
                const sourceEntry = target.closest('.blueprint-source-entry');
                if (sourceEntry) {
                    const detailsContainer = sourceEntry.querySelector('.source-details-container');
                    if (detailsContainer) {
                        createSourceDetailFields(target.value, detailsContainer);
                    }
                }
            }
        }
        
        // Handle clicks in source list (remove buttons)
        function handleSourceListClicks(event) {
            const target = event.target;
            
            // Check if a remove button was clicked
            if (target.classList.contains('remove-source-btn')) {
                const sourceEntry = target.closest('.blueprint-source-entry');
                if (sourceEntry) {
                    // Don't remove if it's the only source
                    const sourceList = document.getElementById('blueprintSourceList');
                    if (sourceList && sourceList.children.length > 1) {
                        sourceEntry.remove();
                    } else {
                        // Reset the fields instead
                        const typeSelect = sourceEntry.querySelector('.blueprintSourceType');
                        if (typeSelect) {
                            typeSelect.value = '';
                            const detailsContainer = sourceEntry.querySelector('.source-details-container');
                            if (detailsContainer) {
                                detailsContainer.innerHTML = '';
                            }
                        }
                    }
                }
            }
        }
        
        // Create dynamic fields based on source type
function createSourceDetailFields(sourceType, container) {
    container.innerHTML = '';
    
    switch(sourceType) {
        case "Bought from Market":
            // Add credit cost input field for Market purchases
            appendInputField(container, "Credit Cost", "number");
            break;
            
        case "Reward from Quest":
            appendSelectField(container, "Quest", blueprintSourceOptions.Quest);
            break;
            
        case "Replicated from Lab":
            appendSelectField(container, "Lab", blueprintSourceOptions.Lab);
            // Add credit cost input field for Lab replications
            appendInputField(container, "Credit Cost", "number");
            break;
            
        case "Sold by Syndicate":
            appendSelectField(container, "Syndicate", blueprintSourceOptions.Syndicate);
            // Add rank selector for Syndicates
            appendSelectField(container, "Required Rank", [
                "Neutral", "Rank 1", "Rank 2", "Rank 3", "Rank 4", "Rank 5"
            ]);
            // Add credit cost input field for Syndicate purchases
            appendInputField(container, "Credit Cost", "number");
            break;
            
        case "Boss Drop":
            appendSelectField(container, "Boss", blueprintSourceOptions.Boss);
            break;
            
        case "Mission Reward":
            appendSelectField(container, "Mission Type", blueprintSourceOptions.Mission.Type);
            appendSelectField(container, "Location", blueprintSourceOptions.Mission.Location);
            break;
            
        case "Junction Reward":
            appendSelectField(container, "Junction", blueprintSourceOptions.Junction);
            break;
            
        case "Enemy Drop":
            appendInputField(container, "Enemy Name");
            break;
            
        case "Bounty Reward":
            appendSelectField(container, "Location", blueprintSourceOptions.Bounty.Location);
            appendSelectField(container, "Bounty Type", blueprintSourceOptions.Bounty.Type);
            break;
            
        case "Assassin Drop":
            appendSelectField(container, "Assassin", blueprintSourceOptions.Assassin);
            break;
            
        case "Void Relics":
            appendSelectField(container, "Relic Tier", blueprintSourceOptions.Relic.Tier);
            appendInputField(container, "Relic Name"); // E.g., "A1", "C3", etc.
            appendSelectField(container, "Rarity", blueprintSourceOptions.Relic.Rarity);
            break;
    }
}
        
        // Helper functions for field creation
        function appendSelectField(container, label, options) {
            const fieldContainer = document.createElement('div');
            fieldContainer.className = 'source-field';
            
            const selectField = document.createElement('select');
            selectField.className = `source-${label.toLowerCase().replace(/\s+/g, '-')}`;
            selectField.setAttribute('data-field', label);
            
            // Add default option
            const defaultOption = document.createElement('option');
            defaultOption.value = "";
            defaultOption.textContent = `Select ${label}`;
            selectField.appendChild(defaultOption);
            
            // Add options
            options.forEach(option => {
                const optionEl = document.createElement('option');
                optionEl.value = option;
                optionEl.textContent = option;
                selectField.appendChild(optionEl);
            });
            
            fieldContainer.innerHTML = `<label>${label}:</label>`;
            fieldContainer.appendChild(selectField);
            container.appendChild(fieldContainer);
        }
        
function appendInputField(container, label, type = "text") {
    const fieldContainer = document.createElement('div');
    fieldContainer.className = 'source-field';
    
    const inputField = document.createElement('input');
    inputField.type = type;
    inputField.className = `source-${label.toLowerCase().replace(/\s+/g, '-')}`;
    inputField.setAttribute('data-field', label);
    inputField.placeholder = `Enter ${label}`;
    
    // Add specific attributes for number type
    if (type === "number") {
        inputField.min = "0";
        inputField.step = "1";
    }
    
    fieldContainer.innerHTML = `<label>${label}:</label>`;
    fieldContainer.appendChild(inputField);
    container.appendChild(fieldContainer);
}
        
        // Get blueprint sources from the UI
        function getBlueprintSources() {
            const sourceList = document.getElementById('blueprintSourceList');
            if (!sourceList) return [];
            
            const sources = [];
            const sourceEntries = sourceList.querySelectorAll('.blueprint-source-entry');
            
            sourceEntries.forEach(entry => {
                const typeSelect = entry.querySelector('.blueprintSourceType');
                if (!typeSelect || !typeSelect.value) return;
                
                const source = {
                    type: typeSelect.value,
                    details: {}
                };
                
                // Get details based on type
                const detailsContainer = entry.querySelector('.source-details-container');
                if (!detailsContainer) return;
                
                // Collect all field values
                detailsContainer.querySelectorAll('select, input').forEach(field => {
                    const fieldName = field.getAttribute('data-field');
                    if (fieldName) {
                        source.details[fieldName] = field.value;
                    }
                });
                
                // Only add if the source type is selected
                if (source.type) {
                    sources.push(source);
                }
            });
            
            return sources;
        }
        
        // Set blueprint sources in the UI
        function setBlueprintSources(sources) {
            const sourceList = document.getElementById('blueprintSourceList');
            if (!sourceList) return;
            
            // Clear current sources
            sourceList.innerHTML = '';
            
            // If no sources provided, add an empty one
            if (!sources || sources.length === 0) {
                addBlueprintSource();
                return;
            }
            
            // Add each source
            sources.forEach(source => {
                // Add a new source entry
                addBlueprintSource();
                
                // Get the last added entry
                const sourceEntry = sourceList.lastElementChild;
                if (!sourceEntry) return;
                
                // Set source type
                const typeSelect = sourceEntry.querySelector('.blueprintSourceType');
                if (typeSelect) {
                    typeSelect.value = source.type;
                    
                    // Create detail fields
                    const detailsContainer = sourceEntry.querySelector('.source-details-container');
                    if (detailsContainer) {
                        createSourceDetailFields(source.type, detailsContainer);
                        
                        // Set field values
                        if (source.details) {
                            for (const [key, value] of Object.entries(source.details)) {
                                const field = detailsContainer.querySelector(`[data-field="${key}"]`);
                                if (field) {
                                    field.value = value;
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // Format blueprint sources for display
        function formatDetailedBlueprintSources(item) {
            // Check if item has blueprint sources in the new format
            if (item.blueprintSources && item.blueprintSources.length > 0) {
                // Create a more detailed display of blueprint sources
                return `
                    <div class="blueprint-sources-container">
                        ${item.blueprintSources.map((source, index) => {
                            return `
                                <div class="blueprint-source-entry ${getSourceTypeClass(source.type)}" data-source-index="${index}">
                                    <div class="blueprint-source-type">${source.type}</div>
                                    ${formatSourceDetails(source)}
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            } 
            // Backward compatibility with old format
            else if (item.blueprintSource) {
                return `<div class="blueprint-source-legacy">${item.blueprintSource}</div>`;
            } 
            // No source info
            else {
                return '<div class="blueprint-source-none">None</div>';
            }
        }
        
        // Helper function to format source details for display
function formatSourceDetails(source) {
    if (!source.details || Object.keys(source.details).length === 0) {
        return '';
    }
    
    let html = '<div class="blueprint-source-details">';
    
    // Process each detail according to source type
    switch (source.type) {
        case "Bought from Market":
            if (source.details["Credit Cost"]) {
                html += `<div><span class="detail-label">Cost:</span> <span class="detail-value">${parseInt(source.details["Credit Cost"]).toLocaleString()} Credits</span></div>`;
            }
            break;
            
        case "Reward from Quest":
            if (source.details.Quest) {
                html += `<div><span class="detail-label">Quest:</span> <span class="detail-value">${source.details.Quest}</span></div>`;
            }
            break;
            
        case "Replicated from Lab":
            if (source.details.Lab) {
                html += `<div><span class="detail-label">Lab:</span> <span class="detail-value">${source.details.Lab}</span></div>`;
            }
            if (source.details["Credit Cost"]) {
                html += `<div><span class="detail-label">Cost:</span> <span class="detail-value">${parseInt(source.details["Credit Cost"]).toLocaleString()} Credits</span></div>`;
            }
            break;
            
        case "Sold by Syndicate":
            if (source.details.Syndicate) {
                html += `<div><span class="detail-label">Syndicate:</span> <span class="detail-value">${source.details.Syndicate}</span></div>`;
            }
            if (source.details["Required Rank"]) {
                html += `<div><span class="detail-label">Rank:</span> <span class="detail-value">${source.details["Required Rank"]}</span></div>`;
            }
            if (source.details["Credit Cost"]) {
                html += `<div><span class="detail-label">Cost:</span> <span class="detail-value">${parseInt(source.details["Credit Cost"]).toLocaleString()} Credits</span></div>`;
            }
            break;
            
        case "Boss Drop":
            if (source.details.Boss) {
                html += `<div><span class="detail-label">Boss:</span> <span class="detail-value">${source.details.Boss}</span></div>`;
            }
            break;
            
        case "Mission Reward":
            let missionDetails = [];
            if (source.details["Mission Type"]) {
                missionDetails.push(`<span class="detail-label">Type:</span> <span class="detail-value">${source.details["Mission Type"]}</span>`);
            }
            if (source.details.Location) {
                missionDetails.push(`<span class="detail-label">Location:</span> <span class="detail-value">${source.details.Location}</span>`);
            }
            html += missionDetails.join(', ');
            break;
            
        case "Junction Reward":
            if (source.details.Junction) {
                html += `<div><span class="detail-label">Junction:</span> <span class="detail-value">${source.details.Junction}</span></div>`;
            }
            break;
            
        case "Enemy Drop":
            if (source.details["Enemy Name"]) {
                html += `<div><span class="detail-label">Enemy:</span> <span class="detail-value">${source.details["Enemy Name"]}</span></div>`;
            }
            break;
            
        case "Bounty Reward":
            let bountyDetails = [];
            if (source.details.Location) {
                bountyDetails.push(`<span class="detail-label">Location:</span> <span class="detail-value">${source.details.Location}</span>`);
            }
            if (source.details["Bounty Type"]) {
                bountyDetails.push(`<span class="detail-label">Type:</span> <span class="detail-value">${source.details["Bounty Type"]}</span>`);
            }
            html += bountyDetails.join(', ');
            break;
            
        case "Assassin Drop":
            if (source.details.Assassin) {
                html += `<div><span class="detail-label">Assassin:</span> <span class="detail-value">${source.details.Assassin}</span></div>`;
            }
            break;
            
        case "Void Relics":
            let relicDetails = [];
            if (source.details["Relic Tier"]) {
                relicDetails.push(`<span class="detail-label">Tier:</span> <span class="detail-value">${source.details["Relic Tier"]}</span>`);
            }
            if (source.details["Relic Name"]) {
                relicDetails.push(`<span class="detail-label">Name:</span> <span class="detail-value">${source.details["Relic Name"]}</span>`);
            }
            if (source.details.Rarity) {
                relicDetails.push(`<span class="detail-label">Rarity:</span> <span class="detail-value detail-rarity-${source.details.Rarity.toLowerCase()}">${source.details.Rarity}</span>`);
            }
            html += relicDetails.join(', ');
            break;
            
        default:
            // For other source types without specific formatting
            Object.entries(source.details).forEach(([key, value]) => {
                if (value) {
                    html += `<span class="detail-label">${key}:</span> <span class="detail-value">${value}</span>, `;
                }
            });
            // Remove trailing comma and space if present
            html = html.replace(/, $/, '');
    }
    
    html += '</div>'; // Close blueprint-source-details
    return html;
}
        
        // Helper function to get CSS class based on source type
        function getSourceTypeClass(sourceType) {
            // Convert source type to a CSS class by replacing spaces with dashes and lowercase
            const baseClass = 'source-type-' + sourceType.toLowerCase().replace(/\s+/g, '-');
            
            // Group similar source types for styling
            if (sourceType.includes('Quest')) {
                return baseClass + ' source-group-quest';
            } else if (sourceType.includes('Boss') || sourceType.includes('Assassin')) {
                return baseClass + ' source-group-boss';
            } else if (sourceType.includes('Syndicate')) {
                return baseClass + ' source-group-syndicate';
            } else if (sourceType.includes('Mission') || sourceType.includes('Junction')) {
                return baseClass + ' source-group-mission';
            } else if (sourceType.includes('Relic')) {
                return baseClass + ' source-group-relic';
            } else if (sourceType.includes('Enemy')) {
                return baseClass + ' source-group-enemy';
            } else if (sourceType.includes('Bounty')) {
                return baseClass + ' source-group-bounty';
            } else if (sourceType.includes('Lab')) {
                return baseClass + ' source-group-lab';
            } else if (sourceType.includes('Market')) {
                return baseClass + ' source-group-market';
            } else {
                return baseClass + ' source-group-other';
            }
        }
        
        // Filter items by source type
        function filterItemsBySourceType() {
            const sourceTypeFilter = document.getElementById('source-type-filter');
            if (!sourceTypeFilter) return;
            
            const selectedSourceType = sourceTypeFilter.value;
            
            // Also update source detail filter if it exists
            const sourceDetailFilter = document.getElementById('source-detail-filter');
            const detailFilterValue = sourceDetailFilter ? sourceDetailFilter.value.toLowerCase() : '';
            
            filterItemsTable(selectedSourceType, detailFilterValue);
        }
        
        // Filter items by source detail
        function filterItemsBySourceDetail() {
            const sourceDetailFilter = document.getElementById('source-detail-filter');
            if (!sourceDetailFilter) return;
            
            const detailFilterValue = sourceDetailFilter.value.toLowerCase();
            
            // Also get source type filter if it exists
            const sourceTypeFilter = document.getElementById('source-type-filter');
            const selectedSourceType = sourceTypeFilter ? sourceTypeFilter.value : 'All';
            
            filterItemsTable(selectedSourceType, detailFilterValue);
        }
        
        // Main filter function for items table
        function filterItemsTable(sourceType, detailValue) {
            const itemRows = document.querySelectorAll('#itemsList tr');
            
            itemRows.forEach(row => {
                let showRow = true;
                
                // Source type filtering
                if (sourceType !== 'All') {
                    const sourceCell = row.querySelector('.blueprint-sources-cell');
                    if (sourceCell) {
                        // For the "None" option, check if there are no sources
                        if (sourceType === 'None') {
                            const hasSource = !sourceCell.querySelector('.blueprint-source-none');
                            showRow = !hasSource;
                        } else {
                            const hasSourceType = sourceCell.textContent.includes(sourceType);
                            showRow = hasSourceType;
                        }
                    }
                }
                
                // Source detail filtering (if source type passes and detail filter is not empty)
                if (showRow && detailValue) {
                    const sourceCell = row.querySelector('.blueprint-sources-cell');
                    if (sourceCell) {
                        const sourceDetails = sourceCell.textContent.toLowerCase();
                        showRow = sourceDetails.includes(detailValue);
                    }
                }
                
                // Show or hide row based on filters
                row.style.display = showRow ? '' : 'none';
            });
        }
        
        /**************************
         * SYNDICATE MANAGER SECTION *
         **************************/
        function initializeSyndicateManager() {
            // Cache DOM elements
            const syndicateNameInput = document.getElementById('syndicateName');
            const syndicateDescriptionInput = document.getElementById('syndicateDescription');
            const syndicateImageInput = document.getElementById('syndicateImage');
            const addSyndicateBtn = document.getElementById('addSyndicateBtn');
            const clearSyndicatesBtn = document.getElementById('clearSyndicatesBtn');
            const syndicatesList = document.getElementById('syndicatesList');
            
            // Modal elements
            const rankModal = document.getElementById('rankModal');
            const closeModalBtn = document.querySelector('.close-modal');
            const currentSyndicateNameSpan = document.getElementById('currentSyndicateName');
            const rankNameInput = document.getElementById('rankName');
            const standingRequiredInput = document.getElementById('standingRequired');
            const initiationCreditsInput = document.getElementById('initiationCredits');
            const rankResourceName = document.getElementById('rankResourceName');
            const rankResourceQuantity = document.getElementById('rankResourceQuantity');
            const rankResourceSelection = document.getElementById('rankResourceSelection');
            const rankSelectedResources = document.getElementById('rankSelectedResources');
            const addRankBtn = document.getElementById('addRankBtn');
            const syndicateRanksList = document.getElementById('syndicateRanksList');
            
            // Populate resource select for rank resources
            populateResourceAndItemSelects();
            
            // Add event listeners
            if (addSyndicateBtn) addSyndicateBtn.addEventListener('click', addSyndicate);
            if (clearSyndicatesBtn) clearSyndicatesBtn.addEventListener('click', clearSyndicates);
            if (closeModalBtn) closeModalBtn.addEventListener('click', closeRankModal);
            if (addRankBtn) addRankBtn.addEventListener('click', addSyndicateRank);
            
            // Event delegation for rank resource selection
            if (rankResourceSelection) {
                rankResourceSelection.addEventListener('click', (e) => {
                    if (e.target.classList.contains('addResourceBtn')) {
                        addRankResource();
                    }
                });
            }
            
            // Event delegation for removing selected resources
            if (rankSelectedResources) {
                rankSelectedResources.addEventListener('click', (e) => {
                    if (e.target.classList.contains('remove-resource-btn')) {
                        e.target.parentElement.remove();
                    }
                });
            }
            
            // Close modal when clicking outside of it
            if (rankModal) {
                window.addEventListener('click', (e) => {
                    if (e.target === rankModal) {
                        closeRankModal();
                    }
                });
            }
            
            // Initial render
            renderSyndicates();
            
            // Add syndicate
            function addSyndicate() {
                const name = syndicateNameInput.value.trim();
                
                if (!name) {
                    alert('Syndicate name is required!');
                    return;
                }
                
                const syndicate = {
                    name: name,
                    description: syndicateDescriptionInput.value.trim(),
                    image: syndicateImageInput.value.trim(),
                    ranks: []
                };
                
                syndicates.push(syndicate);
                
                // Reset form
                syndicateNameInput.value = '';
                syndicateDescriptionInput.value = '';
                syndicateImageInput.value = '';
                
                // Save and update UI
                saveSyndicates();
                renderSyndicates();
            }
            
            // Clear all syndicates
            function clearSyndicates() {
                if (confirm('Are you sure you want to delete ALL syndicates? This cannot be undone.')) {
                    syndicates = [];
                    saveSyndicates();
                    renderSyndicates();
                    alert('All syndicates have been cleared.');
                }
            }
            
            // Render syndicates
            function renderSyndicates() {
                if (!syndicatesList) return;
                
                if (syndicates.length === 0) {
                    syndicatesList.innerHTML = '<div class="empty-message">No syndicates added yet</div>';
                    return;
                }
                
                syndicatesList.innerHTML = '';
                
                syndicates.forEach((syndicate, index) => {
                    const syndicateElement = document.createElement('div');
                    syndicateElement.className = 'syndicate-card';
                    
                    // Create ranks HTML
                    let ranksHTML = '';
                    
                    if (syndicate.ranks.length === 0) {
                        ranksHTML = '<div class="empty-message">No ranks added yet</div>';
                    } else {
                        ranksHTML = '<div class="syndicate-ranks">';
                        
                        syndicate.ranks.forEach(rank => {
                            // Create resource requirements HTML
                            let resourcesHTML = '';
                            if (rank.resources && rank.resources.length > 0) {
                                resourcesHTML = '<div>Resources:';
                                rank.resources.forEach(resource => {
                                    resourcesHTML += ` ${resource.name} x${resource.quantity},`;
                                });
                                // Remove trailing comma
                                resourcesHTML = resourcesHTML.slice(0, -1);
                                resourcesHTML += '</div>';
                            }
                            
                            ranksHTML += `
                                <div class="rank-item">
                                    <div class="rank-header">
                                        <div>${rank.name}</div>
                                        <div>${rank.standingRequired.toLocaleString()} Standing</div>
                                    </div>
                                    <div class="rank-requirements">
                                        <div>Initiation: ${rank.initiationCredits.toLocaleString()} Credits</div>
                                        ${resourcesHTML}
                                    </div>
                                </div>
                            `;
                        });
                        
                        ranksHTML += '</div>';
                    }
                    
                    syndicateElement.innerHTML = `
                        <div class="syndicate-header">
                            <div class="syndicate-logo">
                                ${syndicate.image ? 
                                    `<img src="${syndicate.image}" alt="${syndicate.name}" onerror="this.onerror=null; this.src='https://via.placeholder.com/60'; this.style.opacity=0.5;">` : 
                                    `<span style="font-size: 28px;">${syndicate.name.charAt(0)}</span>`}
                            </div>
                            <div class="syndicate-info">
                                <div class="syndicate-name">${syndicate.name}</div>
                                <div class="syndicate-description">${syndicate.description || 'No description'}</div>
                            </div>
                        </div>
                        
                        <button class="btn manage-ranks-btn" data-index="${index}">Manage Ranks</button>
                        
                        ${ranksHTML}
                        
                        <div class="syndicate-actions">
                            <button class="btn btn-red delete-syndicate-btn" data-index="${index}">Delete</button>
                        </div>
                    `;
                    
                    // Add event listeners
                    const manageRanksBtn = syndicateElement.querySelector('.manage-ranks-btn');
                    const deleteSyndicateBtn = syndicateElement.querySelector('.delete-syndicate-btn');
                    
                    if (manageRanksBtn) {
                        manageRanksBtn.addEventListener('click', () => {
                            openRankModal(index);
                        });
                    }
                    
                    if (deleteSyndicateBtn) {
                        deleteSyndicateBtn.addEventListener('click', () => {
                            deleteSyndicate(index);
                        });
                    }
                    
                    syndicatesList.appendChild(syndicateElement);
                });
            }
            
            // Delete syndicate
            function deleteSyndicate(index) {
                if (confirm(`Are you sure you want to delete "${syndicates[index].name}"?`)) {
                    syndicates.splice(index, 1);
                    saveSyndicates();
                    renderSyndicates();
                }
            }
            
            // Open rank management modal
            function openRankModal(syndicateIndex) {
                currentSyndicateIndex = syndicateIndex;
                if (currentSyndicateNameSpan) {
                    currentSyndicateNameSpan.textContent = syndicates[syndicateIndex].name;
                }
                
                // Clear form
                if (rankNameInput) rankNameInput.value = '';
                if (standingRequiredInput) standingRequiredInput.value = '';
                if (initiationCreditsInput) initiationCreditsInput.value = '';
                if (rankResourceName) rankResourceName.value = '';
                if (rankResourceQuantity) rankResourceQuantity.value = '';
                if (rankSelectedResources) rankSelectedResources.innerHTML = '';
                
                // Render current ranks
                renderSyndicateRanks();
                
                // Show modal
                if (rankModal) rankModal.style.display = 'block';
            }
            
            // Close rank management modal
            function closeRankModal() {
                if (rankModal) rankModal.style.display = 'none';
                currentSyndicateIndex = -1;
            }
            
            // Add resource to selected resources list for rank
            function addRankResource() {
                if (!rankResourceName || !rankResourceQuantity || !rankSelectedResources) return;
                
                const selectedResource = rankResourceName.value;
                const quantity = rankResourceQuantity.value;
                
                if (selectedResource && quantity) {
                    const iconUrl = getResourceIcon(selectedResource);
                    
                    const listItem = document.createElement('li');
                    listItem.innerHTML = `
                        <span class="resource-icon" style="background-image: url(${iconUrl})"></span>
                        <span class="resource-name">${selectedResource}</span> x 
                        <span class="resource-quantity">${quantity}</span>
                        <button class="btn btn-red remove-resource-btn">Remove</button>
                    `;
                    
                    rankSelectedResources.appendChild(listItem);
                    
                    // Clear inputs for next entry
                    rankResourceName.value = '';
                    rankResourceQuantity.value = '';
                }
            }
            
            // Get selected resources for rank
            function getRankSelectedResources() {
                if (!rankSelectedResources) return [];
                
                const resources = [];
                const items = rankSelectedResources.children;
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    const name = item.querySelector('.resource-name')?.textContent;
                    const quantity = item.querySelector('.resource-quantity')?.textContent;
                    
                    if (name && quantity) {
                        resources.push({ 
                            name: name.trim(), 
                            quantity: parseInt(quantity) 
                        });
                    }
                }
                
                return resources;
            }
            
            // Add new rank to syndicate
            function addSyndicateRank() {
                if (currentSyndicateIndex === -1) return;
                
                if (!rankNameInput || !standingRequiredInput || !initiationCreditsInput) return;
                
                const name = rankNameInput.value.trim();
                const standingRequired = parseInt(standingRequiredInput.value) || 0;
                const initiationCredits = parseInt(initiationCreditsInput.value) || 0;
                
                if (!name) {
                    alert('Rank name is required!');
                    return;
                }
                
                const rank = {
                    name: name,
                    standingRequired: standingRequired,
                    initiationCredits: initiationCredits,
                    resources: getRankSelectedResources()
                };
                
                // Add rank to syndicate
                syndicates[currentSyndicateIndex].ranks.push(rank);
                
                // Sort ranks by standing required
                syndicates[currentSyndicateIndex].ranks.sort((a, b) => a.standingRequired - b.standingRequired);
                
                // Save and update UI
                saveSyndicates();
                renderSyndicateRanks();
                renderSyndicates();
                
                // Clear form for next entry
                rankNameInput.value = '';
                standingRequiredInput.value = '';
                initiationCreditsInput.value = '';
                rankSelectedResources.innerHTML = '';
            }
            
            // Render syndicate ranks in modal
            function renderSyndicateRanks() {
                if (currentSyndicateIndex === -1 || !syndicateRanksList) return;
                
                const ranks = syndicates[currentSyndicateIndex].ranks;
                
                if (ranks.length === 0) {
                    syndicateRanksList.innerHTML = '<div class="empty-message">No ranks added yet</div>';
                    return;
                }
                
                syndicateRanksList.innerHTML = '';
                
                ranks.forEach((rank, index) => {
                    const rankElement = document.createElement('div');
                    rankElement.className = 'rank-item';
                    
                    // Create resource requirements HTML
                    let resourcesHTML = '';
                    if (rank.resources && rank.resources.length > 0) {
                        resourcesHTML = '<div>Resources:';
                        rank.resources.forEach(resource => {
                            resourcesHTML += ` ${resource.name} x${resource.quantity},`;
                        });
                        // Remove trailing comma
                        resourcesHTML = resourcesHTML.slice(0, -1);
                        resourcesHTML += '</div>';
                    }
                    
                    rankElement.innerHTML = `
                        <div class="rank-header">
                            <div>${rank.name}</div>
                            <div>${rank.standingRequired.toLocaleString()} Standing</div>
                        </div>
                        <div class="rank-requirements">
                            <div>Initiation: ${rank.initiationCredits.toLocaleString()} Credits</div>
                            ${resourcesHTML}
                        </div>
                        <button class="btn btn-red delete-rank-btn" data-index="${index}">Delete</button>
                    `;
                    
                    // Add event listener for delete button
                    const deleteRankBtn = rankElement.querySelector('.delete-rank-btn');
                    if (deleteRankBtn) {
                        deleteRankBtn.addEventListener('click', () => {
                            deleteRank(index);
                        });
                    }
                    
                    syndicateRanksList.appendChild(rankElement);
                });
            }
            
            // Delete rank
            function deleteRank(rankIndex) {
                if (currentSyndicateIndex === -1) return;
                
                if (confirm('Are you sure you want to delete this rank?')) {
                    syndicates[currentSyndicateIndex].ranks.splice(rankIndex, 1);
                    saveSyndicates();
                    renderSyndicateRanks();
                    renderSyndicates();
                }
            }
        }
        
        /**************************
         * INVENTORY TRACKER SECTION *
         **************************/
        function initializeInventory() {
            const currentCreditsInput = document.getElementById('currentCredits');
            const saveCreditsBtn = document.getElementById('saveCreditsBtn');
            const sortInventoryBtn = document.getElementById('sortInventoryBtn');
            
            // Set initial credits value
            if (currentCreditsInput) currentCreditsInput.value = inventory.credits;
            
            // Add event listener for saving credits
            if (saveCreditsBtn) {
                saveCreditsBtn.addEventListener('click', function() {
                    const credits = parseInt(currentCreditsInput.value) || 0;
                    inventory.credits = credits;
                    saveInventory();
                    // Also update calculator if open
                    calculateTotals();
                });
            }
            
            // Add event listener for sorting inventory
            if (sortInventoryBtn) {
                sortInventoryBtn.addEventListener('click', function() {
                    renderInventory();
                    showSaveNotification('Inventory display sorted!');
                });
            }
            
            // Initial render
            renderInventory();
        }
        
        // Render inventory resources
function renderInventory() {
    // Store the currently active location before rendering
    const activeLocationTab = document.querySelector('.location-tab.active');
    const activeLocation = activeLocationTab ? activeLocationTab.getAttribute('data-location') : 'All';
    
    // Store active category and subcategory for items
    const activeCategoryTab = document.querySelector('.item-category-tab.active');
    const activeCategory = activeCategoryTab ? activeCategoryTab.getAttribute('data-category') : 'All';
    
    const activeSubcategoryTab = document.querySelector('.item-subcategory-tab.active');
    const activeSubcategory = activeSubcategoryTab ? activeSubcategoryTab.getAttribute('data-subcategory') : 'All';

    const resourceInventoryElement = document.getElementById('resource-inventory');
    const itemInventoryElement = document.getElementById('item-inventory');
    
    if (!resourceInventoryElement || !itemInventoryElement) return;
    
    // Render resource inventory
    if (resources.length === 0) {
        resourceInventoryElement.innerHTML = '<div class="empty-message">No resources available. Add resources in the Resource Manager tab first.</div>';
    } else {
        resourceInventoryElement.innerHTML = '';
        
        // Get search term if available
        const searchInput = document.getElementById('inventory-search');
        const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
        
        // Filter resources by search term
        const filteredResources = resources.filter(resource => 
            !searchTerm || resource.name.toLowerCase().includes(searchTerm)
        );
        
        if (filteredResources.length === 0) {
            resourceInventoryElement.innerHTML = '<div class="empty-message">No matching resources found</div>';
        } else {
            filteredResources.forEach(resource => {
                const resourceElement = document.createElement('div');
                resourceElement.className = 'inventory-resource-card';
                
                // Get current quantity from inventory
                const currentQuantity = inventory.resources[resource.name] || 0;
                
                resourceElement.innerHTML = `
                    <div class="inventory-resource-info">
                        <div class="resource-img">
                            ${resource.image ? `<img src="${resource.image}" alt="${resource.name}" onerror="this.onerror=null; this.src='https://via.placeholder.com/36?text=📦'; this.style.opacity=0.5;">` : '<span>📦</span>'}
                        </div>
                        <div>
                            <div class="resource-name">${resource.name}</div>
                            <div class="resource-rarity">${resource.rarity}</div>
                        </div>
                    </div>
                    <div class="inventory-quantity-control">
                        <input 
                            type="number" 
                            class="inventory-quantity-input" 
                            value="${currentQuantity}" 
                            min="0" 
                            data-resource="${resource.name}" 
                            onchange="updateResourceQuantity(this)"
                        >
                        <button class="btn" onclick="updateResourceQuantity(this.previousElementSibling)">Save</button>
                    </div>
                `;
                
                resourceInventoryElement.appendChild(resourceElement);
            });
        }
    }
    
    // Render item inventory with blueprint tracking
    if (items.length === 0) {
        itemInventoryElement.innerHTML = '<div class="empty-message">No items available. Add items in the Item Manager tab first.</div>';
    } else {
        itemInventoryElement.innerHTML = '';
        
        // Get search term if available
        const searchInput = document.getElementById('inventory-items-search');
        const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
        
        // Filter items by search term
        const filteredItems = items.filter(item => 
            !searchTerm || item.name.toLowerCase().includes(searchTerm)
        );
        
        if (filteredItems.length === 0) {
            itemInventoryElement.innerHTML = '<div class="empty-message">No matching items found</div>';
        } else {
            filteredItems.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'inventory-resource-card';
                
                // Get current quantity from inventory
                const currentQuantity = inventory.items[item.name] || 0;
                
                // Get blueprint quantity from inventory
                const blueprintQuantity = inventory.blueprints[item.name] || 0;
                
                // Get mastery status
                const isMastered = inventory.masteredItems[item.name] || false;
                const providesMastery = item.providesMastery || false;
                
                let masteryHTML = '';
                if (providesMastery) {
                    masteryHTML = `
                        <span class="mastery-indicator" style="margin-left: 5px; font-size: 12px; padding: 2px 6px; 
                            border-radius: 10px; cursor: pointer; background-color: ${isMastered ? '#28a745' : '#dc3545'}; color: white;"
                            onclick="toggleMastery('${item.name.replace(/'/g, "\\'")}', this)">
                            ${isMastered ? 'Mastered' : 'Unmastered'}
                        </span>
                    `;
                }
                
                // Determine if the item has an infinite-use blueprint
                const hasInfiniteBlueprint = item.infiniteUses;
                const blueprintInput = hasInfiniteBlueprint ? 
                    `<div class="blueprint-checkbox">
                        <input type="checkbox" id="bp-${item.name.replace(/\s+/g, '-')}" 
                            ${blueprintQuantity > 0 ? 'checked' : ''} 
                            onchange="updateBlueprintStatus('${item.name.replace(/'/g, "\\'")}', this.checked)">
                        <label for="bp-${item.name.replace(/\s+/g, '-')}">Have Blueprint</label>
                    </div>` : 
                    `<div class="blueprint-input">
                        <label for="bp-qty-${item.name.replace(/\s+/g, '-')}">Blueprints:</label>
                        <input type="number" 
                            id="bp-qty-${item.name.replace(/\s+/g, '-')}" 
                            class="blueprint-quantity-input" 
                            value="${blueprintQuantity}" 
                            min="0" 
                            data-item="${item.name}" 
                            onchange="updateBlueprintQuantity(this)">
                    </div>`;
                
                itemElement.innerHTML = `
                    <div class="inventory-resource-info">
                        <div class="resource-img">
                            ${item.image ? `<img src="${item.image}" alt="${item.name}" onerror="this.onerror=null; this.src='https://via.placeholder.com/36?text=🔨'; this.style.opacity=0.5;">` : '<span>🔨</span>'}
                        </div>
                        <div>
                            <div class="resource-name">${item.name} ${masteryHTML}</div>
                            <div class="resource-rarity">${item.category || 'Uncategorized'}</div>
                            ${blueprintInput}
                        </div>
                    </div>
                    <div class="inventory-quantity-control">
                        <input 
                            type="number" 
                            class="inventory-quantity-input" 
                            value="${currentQuantity}" 
                            min="0" 
                            data-item="${item.name}" 
                            onchange="updateInventoryItemQuantity(this)"
                        >
                        <button class="btn" onclick="updateInventoryItemQuantity(this.previousElementSibling)">Save</button>
                    </div>
                `;
                
                itemInventoryElement.appendChild(itemElement);
            });
        }
    }
    
    // Reapply location filtering after rendering if not "All"
    if (activeLocation !== 'All') {
        setTimeout(() => {
            filterResourcesByLocation(activeLocation);
        }, 0);
    }
    
    // Reapply item category filtering if needed
    if (activeCategory !== 'All') {
        setTimeout(() => {
            currentItemCategory = activeCategory;
            currentItemSubcategory = activeSubcategory;
            filterItemsByCategory();
        }, 0);
    }
}
        
        // Update resource quantity in inventory
        function updateResourceQuantity(input) {
            const resourceName = input.getAttribute('data-resource');
            const quantity = parseInt(input.value) || 0;
            
            // Update inventory
            inventory.resources[resourceName] = quantity;
            saveInventory();
            
            // Also update calculator if open
            calculateTotals();
        }
        
        // Update item quantity in inventory
        function updateInventoryItemQuantity(input) {
            const itemName = input.getAttribute('data-item');
            const quantity = parseInt(input.value) || 0;
            
            // Update inventory
            inventory.items[itemName] = quantity;
            saveInventory();
            
            // Also update calculator if open
            calculateTotals();
        }
        
        // Update blueprint status in inventory
        function updateBlueprintStatus(itemName, hasBlueprint) {
            // For infinite-use blueprints (checkbox)
            inventory.blueprints[itemName] = hasBlueprint ? 1 : 0;
            saveInventory();
            
            // Update calculator if open
            calculateTotals();
        }
        
        // Update blueprint quantity in inventory
        function updateBlueprintQuantity(input) {
            // For single-use blueprints (number input)
            const itemName = input.getAttribute('data-item');
            const quantity = parseInt(input.value) || 0;
            
            // Update inventory
            inventory.blueprints[itemName] = quantity;
            saveInventory();
            
            // Update calculator if open
            calculateTotals();
        }
        
        // Filter inventory resources by search term
        function filterInventoryResources() {
            renderInventory();
        }
        
        // Filter inventory items by search term
        function filterInventoryItems() {
            renderInventory();
        }
        

        /**************************
         * CRAFTING CALCULATOR SECTION *
         **************************/
        function initializeCalculator() {
            // Render available items initially
            renderAvailableItems();
            
            // Add a link to the Mastery Tracker
            const availableItemsElement = document.getElementById('available-items');
            if (availableItemsElement) {
                const masteryLink = document.createElement('div');
                masteryLink.className = 'mastery-link';
                masteryLink.innerHTML = `
                    <p style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px;">
                        Managing what items you've mastered? Visit the 
                        <a href="#" onclick="document.querySelector('.tab[data-tab=mastery]').click(); return false;"
                           style="color: #007bff; text-decoration: underline; cursor: pointer;">
                           Mastery Tracker
                        </a> 
                        tab to track and manage mastery status for all your items.
                    </p>
                `;
                
                // Insert after filters but before items list
                const itemsListElement = availableItemsElement.querySelector('#items-list');
                if (itemsListElement) {
                    availableItemsElement.insertBefore(masteryLink, itemsListElement);
                } else {
                    availableItemsElement.appendChild(masteryLink);
                }
            }
        }
        
        // Function to auto-calculate unmastered items
        function autoCalculateUnmastered() {
            // Clear current selection
            selectedItems = [];
            
            // Get all items that are not mastered and not in excluded categories
            const unmastered = items.filter(item => {
                // Skip items in excluded categories
                if (excludedCategories.includes(item.category)) {
                    return false;
                }
                
                // Only include items that provide mastery
                if (!item.providesMastery) {
                    return false;
                }
                
                // Check if item is not mastered (use inventory.masteredItems for consistency)
                return !inventory.masteredItems[item.name];
            });
            
            // Add all unmastered items to selected items
            unmastered.forEach(item => {
                selectedItems.push({ item, quantity: 1 });
            });
            
            // Update the UI
            renderSelectedItems();
            calculateTotals();
            
            // Show confirmation to user
            if (unmastered.length > 0) {
                alert(`Added ${unmastered.length} unmastered items to the calculator!`);
            } else {
                alert('No unmastered items found to add to the calculator!');
            }
        }
        
        // Add item to selected items
        function addItemToCalculator(item) {
            const existingItemIndex = selectedItems.findIndex(i => i.item.name === item.name);
            
            if (existingItemIndex >= 0) {
                // Increase quantity if already in list
                selectedItems[existingItemIndex].quantity += 1;
            } else {
                // Add new item with quantity 1 and null blueprint override (use inventory value)
                selectedItems.push({ 
                    item, 
                    quantity: 1,
                    blueprintOverride: null // null means use inventory value
                });
            }
            
            renderSelectedItems();
            calculateTotals();
        }
        
        // Remove item from selected items
        function removeItemFromCalculator(index) {
            selectedItems.splice(index, 1);
            renderSelectedItems();
            calculateTotals();
        }
        
        // Update item quantity
        function updateItemQuantity(index, newQuantity) {
            if (newQuantity < 1) return;
            
            selectedItems[index].quantity = newQuantity;
            renderSelectedItems();
            calculateTotals();
        }
        
        // Functions to update blueprint status/quantity in the calculator
function updateCalculatorBlueprintStatus(index, hasBlueprint) {
    // Update the override in selected items
    selectedItems[index].blueprintOverride = hasBlueprint ? 1 : 0;
    
    // Also update inventory - get the item name
    const itemName = selectedItems[index].item.name;
    inventory.blueprints[itemName] = hasBlueprint ? 1 : 0;
    
    // Save inventory to localStorage
    saveInventory();
    
    // Recalculate totals to update UI
    calculateTotals();
    
    // Show notification
    showNotification('Blueprint status updated and saved!', 1500);
}
        
function updateCalculatorBlueprintQuantity(index, quantityStr) {
    // Parse quantity to integer
    const quantity = parseInt(quantityStr) || 0;
    
    // Update the override in selected items
    selectedItems[index].blueprintOverride = quantity;
    
    // Also update inventory - get the item name
    const itemName = selectedItems[index].item.name;
    inventory.blueprints[itemName] = quantity;
    
    // Save inventory to localStorage
    saveInventory();
    
    // Recalculate totals to update UI
    calculateTotals();
    
    // Show notification
    showNotification('Blueprint quantity updated and saved!', 1500);
}
        
        // Modified functions to update component blueprint status/quantity
function updateComponentBlueprintStatus(itemName, hasBlueprint) {
    // Create a special array for component overrides if it doesn't exist
    if (!window.componentBlueprintOverrides) {
        window.componentBlueprintOverrides = {};
    }
    
    // Store the blueprint override in this special object
    window.componentBlueprintOverrides[itemName] = hasBlueprint ? 1 : 0;
    
    // Also update inventory
    inventory.blueprints[itemName] = hasBlueprint ? 1 : 0;
    
    // Save inventory to localStorage
    saveInventory();
    
    // Recalculate totals
    calculateTotals();
    
    // Show notification
    showNotification('Component blueprint status updated and saved!', 1500);
}

// For component blueprint quantity (number input)
function updateComponentBlueprintQuantity(itemName, quantityStr) {
    const quantity = parseInt(quantityStr) || 0;
    
    // Create a special array for component overrides if it doesn't exist
    if (!window.componentBlueprintOverrides) {
        window.componentBlueprintOverrides = {};
    }
    
    // Store the blueprint override in this special object
    window.componentBlueprintOverrides[itemName] = quantity;
    
    // Also update inventory
    inventory.blueprints[itemName] = quantity;
    
    // Save inventory to localStorage
    saveInventory();
    
    // Recalculate totals
    calculateTotals();
    
    // Show notification
    showNotification('Component blueprint quantity updated and saved!', 1500);
}
        
        // Toggle additional sources visibility
        function toggleAdditionalSources(button) {
            const additionalSources = button.nextElementSibling;
            if (additionalSources) {
                const isVisible = additionalSources.style.display !== 'none';
                additionalSources.style.display = isVisible ? 'none' : 'block';
                button.textContent = isVisible ? 
                    `Show ${additionalSources.children.length} more sources` : 
                    'Hide additional sources';
            }
        }
        
        // Render available items list with category filtering
        function renderAvailableItems() {
            const availableItemsElement = document.getElementById('available-items');
            
            if (!availableItemsElement) return;
            
            if (items.length === 0) {
                availableItemsElement.innerHTML = '<div class="empty-message">No items available. Add items in the Item Manager tab first.</div>';
                return;
            }
            
            // Extract all unique categories from imported items
            const categories = [];
            items.forEach(item => {
                if (item.category && !categories.includes(item.category)) {
                    categories.push(item.category);
                }
            });
            
            // Sort categories alphabetically
            categories.sort();
            
            // Add an "All" category at the beginning
            categories.unshift('All');
            
            // Create category filter
            let filterHtml = '<div class="category-filter">';
            filterHtml += '<label for="category-select">Filter by Category: </label>';
            filterHtml += '<select id="category-select" onchange="filterItemsByCategory()">';
            
            categories.forEach(category => {
                filterHtml += `<option value="${category}">${category}</option>`;
            });
            
            filterHtml += '</select></div>';
            
            // Add search filter
            filterHtml += '<div class="search-filter">';
            filterHtml += '<label for="item-search">Search: </label>';
            filterHtml += '<input type="text" id="item-search" placeholder="Search items..." onkeyup="filterItemsBySearch()">';
            filterHtml += '</div>';
            
            // Add auto-calculate button before the items list
            filterHtml += '<button id="auto-calculate-btn" class="btn btn-green auto-calculate-btn" onclick="autoCalculateUnmastered()">Auto-Calculate Unmastered Items</button>';
            
            // Create items list container
            let itemsListHtml = '<div id="items-list" class="items-list"></div>';
            
            // Combine filters and items list
            availableItemsElement.innerHTML = filterHtml + itemsListHtml;
            
            // Initial render of all items
            renderFilteredItems();
        }
        
        // Filter items by category
        function filterItemsByCategory() {
            renderFilteredItems();
        }
        
        // Filter items by search
        function filterItemsBySearch() {
            renderFilteredItems();
        }
        
        // Render filtered items based on category and search
// Render filtered items based on category and search with hidden details
function renderFilteredItems() {
    const itemsListElement = document.getElementById('items-list');
    const categorySelect = document.getElementById('category-select');
    const searchInput = document.getElementById('item-search');
    const excludeMasteredCheckbox = document.getElementById('exclude-mastered');
    
    if (!itemsListElement) return;
    
    const selectedCategory = categorySelect ? categorySelect.value : 'All';
    const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';
    const excludeMastered = excludeMasteredCheckbox ? excludeMasteredCheckbox.checked : false;
    
    // Filter items by category, search term, and mastery status
    const filteredItems = items.filter(item => {
        const matchesCategory = selectedCategory === 'All' || item.category === selectedCategory;
        const matchesSearch = !searchTerm || 
            item.name.toLowerCase().includes(searchTerm) || 
            (item.description && item.description.toLowerCase().includes(searchTerm));
        
        // Check if item should be excluded based on mastery status
        const isExemptCategory = excludedCategories.includes(item.category);
        const shouldExcludeMastered = excludeMastered && 
                                     item.providesMastery && 
                                     inventory.masteredItems[item.name] && 
                                     !isExemptCategory;
        
        return matchesCategory && matchesSearch && !shouldExcludeMastered;
    });
    
    // Clear existing items
    itemsListElement.innerHTML = '';
    
    if (filteredItems.length === 0) {
        itemsListElement.innerHTML = '<div class="empty-message">No matching items found</div>';
        return;
    }
    
    // Add filtered items with proper mastery display
    filteredItems.forEach((item, index) => {
        const originalIndex = items.findIndex(i => i.name === item.name);
        
        const itemElement = document.createElement('div');
        itemElement.className = 'item';
        
        // Check if item is mastered and provides mastery
        const isMastered = inventory.masteredItems[item.name] || false;
        const providesMastery = item.providesMastery || false;
        
        // Get the item image URL
        const itemImage = item.image || '';
        
        // Create a simplified item display with image
        let itemHtml = `
            <div class="inventory-resource-info" style="display: flex; align-items: center; gap: 10px;">
                <div class="resource-img" style="width: 36px; height: 36px; flex-shrink: 0; border-radius: 50%; overflow: hidden; border: 1px solid #ddd; display: flex; justify-content: center; align-items: center; background-color: #f5f5f5;">
                    ${itemImage ? 
                        `<img src="${itemImage}" alt="${item.name}" style="width: 100%; height: 100%; object-fit: contain;" onerror="this.onerror=null; this.src='https://via.placeholder.com/36'; this.style.opacity=0.5;">` : 
                        '<span style="font-size: 18px;">🔨</span>'}
                </div>
                <div class="item-info" style="flex-grow: 1;">`;
        
        // Add item name with appropriate mastery indicator - VISIBLE
        itemHtml += `<div class="item-name">
            ${item.name} 
            ${providesMastery ? 
            `<span class="mastery-indicator" style="margin-left: 5px; font-size: 12px; padding: 2px 6px; border-radius: 10px; cursor: pointer; background-color: ${isMastered ? '#28a745' : '#dc3545'}; color: white;" 
                  onclick="document.querySelector('.tab[data-tab=mastery]').click();">
                ${isMastered ? 'Mastered' : 'Unmastered'}
            </span>` : 
            ''}
        </div>`;
        
        // Add item category if available - VISIBLE
        if (item.category) {
            itemHtml += `<div class="item-category">${item.category}</div>`;
        }
        
        // Add a hidden container for all the details we want to keep but not display
        itemHtml += `<div style="display: none;">`;
        
        // Add blueprint information - HIDDEN
        if (item.infiniteUses) {
            itemHtml += `<div style="color: purple; font-size: 12px;">Reusable blueprint</div>`;
        }
        if (item.multiItemBlueprint) {
            itemHtml += `<div style="color: blue; font-size: 12px;">Creates ${item.itemsPerBlueprint} per blueprint</div>`;
        }
        
        // Add item source if available - HIDDEN
        if (item.blueprintSources && item.blueprintSources.length > 0) {
            const firstSource = item.blueprintSources[0];
            itemHtml += `<div class="item-source">Source: ${firstSource.type}</div>`;
            
            if (item.blueprintSources.length > 1) {
                itemHtml += `<div class="item-source" style="font-style: italic;">(${item.blueprintSources.length} sources available)</div>`;
            }
        } else if (item.blueprintSource) {
            itemHtml += `<div class="item-source">Source: ${item.blueprintSource}</div>`;
        }
        
        // Add build credit cost - HIDDEN
        if (item.buildCreditCost) {
            itemHtml += `<div class="item-credits">Build Credits: ${parseInt(item.buildCreditCost).toLocaleString()}</div>`;
        }
        
        // Add blueprint cost if available - HIDDEN
        if (item.blueprintCost && item.blueprintCost.type === "Credits") {
            itemHtml += `<div class="item-bp-credits">BP Credits: ${parseInt(item.blueprintCost.quantity).toLocaleString()}</div>`;
        } else if (item.blueprintCost && item.blueprintCost.type === "Standing") {
            itemHtml += `<div class="item-bp-standing">Standing: ${parseInt(item.blueprintCost.quantity).toLocaleString()}</div>`;
        } else if (item.blueprintCost && item.blueprintCost.type === "Resource") {
            let resourceName = item.blueprintCost.resource;
            if (resourceName.startsWith("resource:")) resourceName = resourceName.substring(9);
            else if (resourceName.startsWith("item:")) resourceName = resourceName.substring(5);
            
            itemHtml += `<div class="item-bp-resource">BP Cost: ${parseInt(item.blueprintCost.quantity).toLocaleString()} ${resourceName}</div>`;
        }
        
        // Close the hidden container
        itemHtml += `</div>`;
        
        itemHtml += `</div></div>`;
        
        itemElement.innerHTML = `
            ${itemHtml}
            <button class="btn-add" style="margin-left: 10px;" onclick="addItemToCalculator(items[${originalIndex}])">Add</button>
        `;
        itemsListElement.appendChild(itemElement);
    });
}
        
        // Render selected items

            
            // Function to calculate resources for an item directly

            
            // Calculate total credits
            totalCredits = blueprintCredits + buildCredits;
            
            // Render results
            renderTotalResources(totalResources, totalCredits, blueprintCredits, buildCredits, componentItems);
        
        // Render total resources
// Render total resources with inline inventory update
// Render total resources with inline inventory update
function renderTotalResources(totalResources, totalCredits, blueprintCredits, buildCredits, componentItems = {}) {
    // Store expanded states before rendering
    const expandedStates = {};
    
    // Check which sections are currently expanded
    const collapsibles = document.querySelectorAll('[id$="-collapsible"]');
    collapsibles.forEach(el => {
        if (el.style.display !== 'none') {
            expandedStates[el.id] = true;
        }
    });
    
    const totalCreditsElement = document.getElementById('total-credits');
    const totalResourcesElement = document.getElementById('total-resources');
    
    if (!totalCreditsElement || !totalResourcesElement) return;
    
    // Get credits from inventory
    const availableCredits = inventory.credits || 0;
    const creditsNeeded = Math.max(0, totalCredits - availableCredits);
    
    // Update credits display with breakdown
    totalCreditsElement.innerHTML = `
        <div>Total Credits: <span class="credit-amount">${totalCredits.toLocaleString()}</span></div>
        <div class="credit-breakdown">
            <div>Blueprint Costs: ${blueprintCredits.toLocaleString()}</div>
            <div>Build Costs: ${buildCredits.toLocaleString()}</div>
        </div>
        <div class="credit-breakdown" style="margin-top: 10px;">
            <div>Available Credits: ${availableCredits.toLocaleString()}</div>
            <div>Credits Needed: ${creditsNeeded.toLocaleString()}</div>
        </div>
    `;
    
    // Clear the container
    totalResourcesElement.innerHTML = '';
    
    // 1. Add component items section first (if there are any)
    if (componentItems && Object.keys(componentItems).length > 0) {
        const componentItemsId = 'component-items-collapsible';
        const componentSection = document.createElement('div');
        componentSection.className = 'resource-section';
        componentSection.style.marginBottom = '20px';
        
        componentSection.innerHTML = `
            <button class="collapsible-btn" 
                    style="width: 100%; text-align: left; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; cursor: pointer; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 0;"
                    onclick="toggleCollapsible('${componentItemsId}')">
                <span style="font-weight: 600; font-size: 16px;">Component Items Required (${Object.keys(componentItems).length})</span>
                <span class="toggle-icon">▼</span>
            </button>
            <div id="${componentItemsId}" style="display: none; border: 1px solid #ddd; border-top: none; padding: 15px; border-radius: 0 0 4px 4px; background-color: #f9f9f9;">
                <div class="resources-grid" id="component-items-grid"></div>
            </div>
        `;
        
        totalResourcesElement.appendChild(componentSection);
        
        const componentGrid = componentSection.querySelector('#component-items-grid');
        
        Object.entries(componentItems).forEach(([itemName, quantity]) => {
            const itemElement = document.createElement('div');
            itemElement.className = 'resource-card';
            
            // Find the item info
            const itemInfo = items.find(i => i.name === itemName);
            const itemImage = itemInfo?.image || '';
            
            // Get mastery status
            const isMastered = inventory.masteredItems[itemName] || false;
            const providesMastery = itemInfo?.providesMastery || false;
            
            // Get inventory quantity
            const availableQuantity = inventory.items[itemName] || 0;
            const neededQuantity = Math.max(0, quantity - availableQuantity);
            
            // Get current blueprint override or inventory value
            let blueprintOverride = null;
            
            // Check if there's an override in componentBlueprintOverrides
            if (window.componentBlueprintOverrides && window.componentBlueprintOverrides[itemName] !== undefined) {
                blueprintOverride = window.componentBlueprintOverrides[itemName];
            } else {
                // Check if there's an override in selected items (for backward compatibility)
                const selectedItemIndex = selectedItems.findIndex(i => i.item.name === itemName);
                if (selectedItemIndex >= 0 && selectedItems[selectedItemIndex].blueprintOverride !== undefined) {
                    blueprintOverride = selectedItems[selectedItemIndex].blueprintOverride;
                }
            }
            
            // Get blueprint inventory
            const ownedBlueprints = blueprintOverride !== null ? 
                blueprintOverride : 
                (inventory.blueprints[itemName] || 0);
            
            // Create status text and color
            let statusText = '';
            let statusColor = '';
            
            if (availableQuantity >= quantity) {
                statusText = 'Available in Inventory';
                statusColor = '#28a745'; // Green
            } else if (availableQuantity > 0) {
                statusText = 'Partially Available';
                statusColor = '#ffc107'; // Yellow
            } else {
                statusText = 'Need to Craft';
                statusColor = '#dc3545'; // Red
            }
            
            let masteryHTML = '';
            if (providesMastery) {
                masteryHTML = `
                    <span class="mastery-indicator" style="font-size: 12px; padding: 2px 6px; border-radius: 10px; background-color: ${isMastered ? '#28a745' : '#dc3545'}; color: white;">
                        ${isMastered ? 'Mastered' : 'Unmastered'}
                    </span>
                `;
            }
            
            // Create blueprint input control based on type
            let blueprintInputHTML = '';
            if (itemInfo) {
                if (itemInfo.infiniteUses) {
                    // For infinite-use blueprints - checkbox
                    const checkedAttr = ownedBlueprints > 0 ? 'checked' : '';
                    blueprintInputHTML = `
                        <div class="blueprint-checkbox" style="margin-top: 8px; padding: 4px; background-color: #f8f9fa; border-radius: 4px;">
                            <input type="checkbox" id="comp-bp-${itemName.replace(/\s+/g, '-')}" ${checkedAttr} 
                                onchange="updateComponentBlueprintStatus('${itemName.replace(/'/g, "\\'")}', this.checked)">
                            <label for="comp-bp-${itemName.replace(/\s+/g, '-')}">I have this blueprint</label>
                        </div>
                    `;
                } else {
                    // For single-use blueprints - number input
                    blueprintInputHTML = `
                        <div class="blueprint-input" style="margin-top: 8px; padding: 4px; background-color: #f8f9fa; border-radius: 4px; display: flex; align-items: center;">
                            <label for="comp-bp-qty-${itemName.replace(/\s+/g, '-')}" style="margin-right: 5px; font-size: 12px;">Blueprints owned:</label>
                            <input type="number" id="comp-bp-qty-${itemName.replace(/\s+/g, '-')}" class="blueprint-quantity-input" 
                                value="${ownedBlueprints}" min="0" 
                                style="width: 60px; text-align: center; font-size: 12px;"
                                onchange="updateComponentBlueprintQuantity('${itemName.replace(/'/g, "\\'")}', this.value)">
                        </div>
                    `;
                }
            }
            
            // Add blueprint source information with collapsible section
            const componentSourceId = `component-source-${itemName.replace(/\s+/g, '-')}`;
            let blueprintSourceHTML = '';
            if (itemInfo && (itemInfo.blueprintSources || itemInfo.blueprintSource)) {
                blueprintSourceHTML = `
                    <div style="margin-top: 8px;">
                        <button class="collapsible-btn" 
                                style="width: 100%; text-align: left; padding: 4px 8px; background-color: #f0f0f0; border: none; cursor: pointer; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; font-size: 12px;"
                                onclick="toggleCollapsible('${componentSourceId}')">
                            <span style="font-weight: 500;">Blueprint Source</span>
                            <span class="toggle-icon">▼</span>
                        </button>
                        <div id="${componentSourceId}" style="display: none; padding: 8px; border: 1px solid #eee; border-top: none; margin-top: 2px; font-size: 12px;">
                            ${formatDetailedBlueprintSources(itemInfo, true)}
                        </div>
                    </div>
                `;
            }
            
            // Add inventory update controls for component items
            const inventoryUpdateHTML = `
                <div style="margin-top: 8px; padding: 4px; background-color: #f8f9fa; border-radius: 4px; display: flex; align-items: center;">
                    <label style="margin-right: 5px; font-size: 12px;">Inventory quantity:</label>
                    <input type="number" 
                        class="inventory-quantity-input" 
                        value="${availableQuantity}" 
                        min="0" 
                        data-item="${itemName}" 
                        style="width: 60px; text-align: center; font-size: 12px;"
                        oninput="updateInventoryItemQuantityAndPreserveState(this);">
                </div>
            `;
            
            itemElement.innerHTML = `
                <div class="resource-header">
                    <div class="resource-img">
                        ${itemImage ? `<img src="${itemImage}" alt="${itemName}" onerror="this.onerror=null; this.src='https://via.placeholder.com/36'; this.style.opacity=0.5;">` : '<span>🔨</span>'}
                    </div>
                    <div>
                        <div class="resource-name">${itemName} ${masteryHTML}</div>
                        <div class="resource-quantity" style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-weight: bold; ${neededQuantity === 0 ? 'color: #28a745;' : ''}">${neededQuantity === 0 ? 'All required items available' : `Still need to craft: ${neededQuantity.toLocaleString()}`}</span>
                            <span style="color: ${statusColor}; font-weight: bold; font-size: 12px; padding: 2px 6px; border-radius: 4px; background-color: ${statusColor}20;">${statusText}</span>
                        </div>
                        <div style="margin-top: 5px;">
                            <div style="display: flex; justify-content: space-between;">
                                <span>Total required: ${quantity.toLocaleString()}</span>
                                <span>Available: ${availableQuantity.toLocaleString()}</span>
                            </div>
                        </div>
                        ${inventoryUpdateHTML}
                        ${blueprintInputHTML}
                        ${blueprintSourceHTML}
                        <div style="color: #17a2b8; font-style: italic; margin-top: 4px">Component Item</div>
                    </div>
                </div>
            `;
            
            componentGrid.appendChild(itemElement);
        });
    }
    
    // 2. Add raw resources section
    const rawResourcesId = 'raw-resources-collapsible';
    const resourceCount = Object.keys(totalResources).length;
    
    const rawResourcesSection = document.createElement('div');
    rawResourcesSection.className = 'resource-section';
    
    if (resourceCount === 0) {
        rawResourcesSection.innerHTML = '<div class="empty-message">No raw resources required</div>';
    } else {
        rawResourcesSection.innerHTML = `
            <button class="collapsible-btn" 
                    style="width: 100%; text-align: left; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; cursor: pointer; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 0;"
                    onclick="toggleCollapsible('${rawResourcesId}')">
                <span style="font-weight: 600; font-size: 16px;">Raw Resources Required (${resourceCount})</span>
                <span class="toggle-icon">▼</span>
            </button>
            <div id="${rawResourcesId}" style="display: none; border: 1px solid #ddd; border-top: none; padding: 15px; border-radius: 0 0 4px 4px; background-color: #f9f9f9;">
                <div class="resources-grid" id="raw-resources-grid"></div>
            </div>
        `;
        
        totalResourcesElement.appendChild(rawResourcesSection);
        
        const resourcesGridElement = rawResourcesSection.querySelector('#raw-resources-grid');
        
        Object.entries(totalResources).forEach(([resourceName, quantity]) => {
            // Ensure this is an actual resource, not an item
            if (items.some(i => i.name === resourceName)) {
                // This is an item, it should be in componentItems, not here
                console.warn(`Item ${resourceName} found in raw resources, skipping`);
                return;
            }
            
            const resourceElement = document.createElement('div');
            resourceElement.className = 'resource-card';
            
            const resourceImage = getResourceIcon(resourceName);
            const resourceInfo = resources.find(res => res.name === resourceName);
            const resourceLocations = resourceInfo ? resourceInfo.locations : [];
            
            // Get available quantity from inventory
            const availableQuantity = inventory.resources[resourceName] || 0;
            const neededQuantity = Math.max(0, quantity - availableQuantity);
            
            // Create status text and color
            let statusText = '';
            let statusColor = '';
            
            if (availableQuantity >= quantity) {
                statusText = 'Available';
                statusColor = '#28a745'; // Green
            } else if (availableQuantity > 0) {
                statusText = 'Partially Available';
                statusColor = '#ffc107'; // Yellow
            } else {
                statusText = 'Need to Farm';
                statusColor = '#dc3545'; // Red
            }
            
            // Create a collapsible section for locations
            const locationId = `locations-${resourceName.replace(/\s+/g, '-')}`;
            let locationsHTML = '';
            
            if (resourceLocations && resourceLocations.length > 0) {
                locationsHTML = `
                    <div style="margin-top: 8px;">
                        <button class="collapsible-btn" 
                                style="width: 100%; text-align: left; padding: 4px 8px; background-color: #f0f0f0; border: none; cursor: pointer; border-radius: 4px; display: flex; justify-content: space-between; align-items: center; font-size: 12px;"
                                onclick="toggleCollapsible('${locationId}')">
                            <span style="font-weight: 500;">Farming Locations (${resourceLocations.length})</span>
                            <span class="toggle-icon">▼</span>
                        </button>
                        <div id="${locationId}" style="display: none; padding: 8px; border: 1px solid #eee; border-top: none; margin-top: 2px; font-size: 12px;">
                            ${resourceLocations.join(', ')}
                        </div>
                    </div>
                `;
            } else {
                locationsHTML = `<div class="resource-locations" style="margin-top: 8px; font-size: 12px; color: #666;">No known locations</div>`;
            }
            
            // Add inventory update input and button
            const inventoryUpdateHTML = `
                <div style="margin-top: 8px; padding: 4px; background-color: #f8f9fa; border-radius: 4px; display: flex; align-items: center;">
                    <label style="margin-right: 5px; font-size: 12px;">Inventory quantity:</label>
                    <input type="number" 
                        class="inventory-quantity-input" 
                        value="${availableQuantity}" 
                        min="0" 
                        data-resource="${resourceName}" 
                        style="width: 60px; text-align: center; font-size: 12px;"
                        oninput="updateResourceQuantityAndPreserveState(this);">
                </div>
            `;
            
            resourceElement.innerHTML = `
                <div class="resource-header">
                    <div class="resource-img">
                        ${resourceImage ? `<img src="${resourceImage}" alt="${resourceName}" onerror="this.onerror=null; this.src='https://via.placeholder.com/36'; this.style.opacity=0.5;">` : '<span>📦</span>'}
                    </div>
                    <div>
                        <div class="resource-name">${resourceName}</div>
                        <div class="resource-quantity" style="display: flex; align-items: center; gap: 8px;">
                            <span style="font-weight: bold; ${neededQuantity === 0 ? 'color: #28a745;' : ''}">${neededQuantity === 0 ? 'All required resources available' : `Still need: ${neededQuantity.toLocaleString()}`}</span>
                            <span style="color: ${statusColor}; font-weight: bold; font-size: 12px; padding: 2px 6px; border-radius: 4px; background-color: ${statusColor}20;">${statusText}</span>
                        </div>
                        <div style="margin-top: 5px;">
                            <div style="display: flex; justify-content: space-between;">
                                <span>Total required: ${quantity.toLocaleString()}</span>
                                <span>Available: ${availableQuantity.toLocaleString()}</span>
                            </div>
                        </div>
                        ${inventoryUpdateHTML}
                        ${locationsHTML}
                    </div>
                </div>
            `;
            
            resourcesGridElement.appendChild(resourceElement);
        });
    }
    
    // Auto-expand sections based on previously expanded states or default behavior
    setTimeout(() => {
        // First restore any previously expanded states
        for (const [id, wasExpanded] of Object.entries(expandedStates)) {
            if (wasExpanded && document.getElementById(id)) {
                document.getElementById(id).style.display = 'block';
                
                // Also update toggle icons if any
                const toggleBtn = document.querySelector(`button[onclick="toggleCollapsible('${id}')"]`);
                if (toggleBtn) {
                    const icon = toggleBtn.querySelector('.toggle-icon');
                    if (icon) {
                        icon.textContent = '▲';
                    }
                }
            }
        }
        
        // If no states were restored, use default behavior for small number of items
        if (Object.keys(expandedStates).length === 0) {
            if (resourceCount > 0 && resourceCount <= 3) {
                toggleCollapsible(rawResourcesId);
            }
            
            const componentCount = Object.keys(componentItems).length;
            if (componentCount > 0 && componentCount <= 3) {
                toggleCollapsible(componentItemsId);
            }
        }
    }, 1);
    
    totalResourcesElement.appendChild(rawResourcesSection);
}
// Functions to update inventory quantities with minimal refresh

// Update resource quantity with minimal UI refresh
function updateResourceQuantityAndPreserveState(input) {
    // Debounce the input to prevent excessive updates
    if (input._timeoutId) clearTimeout(input._timeoutId);
    
    input._timeoutId = setTimeout(() => {
        // Get resource name and quantity
        const resourceName = input.getAttribute('data-resource');
        const newQuantity = parseInt(input.value) || 0;
        
        // Update inventory data
        inventory.resources[resourceName] = newQuantity;
        saveInventory();
        
        // Store expanded sections
        const expandedSections = {};
        document.querySelectorAll('[id$="-collapsible"]').forEach(section => {
            if (section.style.display !== 'none') {
                expandedSections[section.id] = true;
            }
        });
        
        // Update only what's needed - recalculate totals but preserve expanded sections
        calculateTotals();
        
        // Restore expanded sections
        setTimeout(() => {
            for (const [id, isExpanded] of Object.entries(expandedSections)) {
                const section = document.getElementById(id);
                if (section && isExpanded) {
                    section.style.display = 'block';
                    
                    // Also update toggle icon
                    const btn = document.querySelector(`button[onclick="toggleCollapsible('${id}')"]`);
                    if (btn) {
                        const icon = btn.querySelector('.toggle-icon');
                        if (icon) icon.textContent = '▲';
                    }
                }
            }
        }, 1);
        
        // Show a quick notification
        showQuickNotification(`${resourceName} updated to ${newQuantity}`);
    }, 10); // 300ms debounce delay
}

// Update item quantity with minimal UI refresh 
function updateInventoryItemQuantityAndPreserveState(input) {
    // Debounce the input to prevent excessive updates
    if (input._timeoutId) clearTimeout(input._timeoutId);
    
    input._timeoutId = setTimeout(() => {
        // Get item name and quantity
        const itemName = input.getAttribute('data-item');
        const newQuantity = parseInt(input.value) || 0;
        
        // Update inventory data
        inventory.items[itemName] = newQuantity;
        saveInventory();
        
        // Store expanded sections
        const expandedSections = {};
        document.querySelectorAll('[id$="-collapsible"]').forEach(section => {
            if (section.style.display !== 'none') {
                expandedSections[section.id] = true;
            }
        });
        
        // Update only what's needed - recalculate totals but preserve expanded sections
        calculateTotals();
        
        // Restore expanded sections
        setTimeout(() => {
            for (const [id, isExpanded] of Object.entries(expandedSections)) {
                const section = document.getElementById(id);
                if (section && isExpanded) {
                    section.style.display = 'block';
                    
                    // Also update toggle icon
                    const btn = document.querySelector(`button[onclick="toggleCollapsible('${id}')"]`);
                    if (btn) {
                        const icon = btn.querySelector('.toggle-icon');
                        if (icon) icon.textContent = '▲';
                    }
                }
            }
        }, 1);
        
        // Show a quick notification
        showQuickNotification(`${itemName} updated to ${newQuantity}`);
    }, 300); // 300ms debounce delay
}

// Show a quick, non-intrusive notification
function showQuickNotification(message) {
    // Check if notification element exists already
    let notif = document.getElementById('quick-notification');
    
    // Create if it doesn't exist
    if (!notif) {
        notif = document.createElement('div');
        notif.id = 'quick-notification';
        notif.style.position = 'fixed';
        notif.style.bottom = '10px';
        notif.style.right = '10px';
        notif.style.backgroundColor = 'rgba(40, 167, 69, 0.9)';
        notif.style.color = 'white';
        notif.style.padding = '8px 12px';
        notif.style.borderRadius = '4px';
        notif.style.fontSize = '14px';
        notif.style.opacity = '0';
        notif.style.transition = 'opacity 0.3s';
        notif.style.zIndex = '1000';
        document.body.appendChild(notif);
    }
    
    // Update message and show
    notif.textContent = message;
    notif.style.opacity = '1';
    
    // Hide after delay
    setTimeout(() => {
        notif.style.opacity = '0';
    }, 1500);
}
        
        /**************************
         * MASTERY TRACKER SECTION *
         **************************/
        function initializeMasteryTracker() {
            // Cache DOM elements
            const masteryContainer = document.getElementById('mastery-items-container');
            const categorySelect = document.getElementById('mastery-category-select');
            const searchInput = document.getElementById('mastery-search');
            const progressBar = document.getElementById('mastery-progress-bar');
            const masteryTotalCount = document.getElementById('mastery-total-count');
            const masteryAvailableCount = document.getElementById('mastery-available-count');
            const markAllMasteredBtn = document.getElementById('mark-all-mastered-btn');
            const markAllUnmasteredBtn = document.getElementById('mark-all-unmastered-btn');
            const addUnmasteredToCalcBtn = document.getElementById('add-unmastered-to-calc-btn');
            
            // Populate category dropdown with all categories that provide mastery
            populateMasteryCategories();
            
            // Initial render of mastery items
            renderMasteryItems();
            updateMasteryProgress();
            
            // Add event listeners
            if (markAllMasteredBtn) {
                markAllMasteredBtn.addEventListener('click', function() {
                    const category = categorySelect.value;
                    markAllInCategoryAs(category, true);
                });
            }
            
            if (markAllUnmasteredBtn) {
                markAllUnmasteredBtn.addEventListener('click', function() {
                    const category = categorySelect.value;
                    markAllInCategoryAs(category, false);
                });
            }
            
            if (addUnmasteredToCalcBtn) {
                addUnmasteredToCalcBtn.addEventListener('click', function() {
                    addUnmasteredToCalculator();
                });
            }
            
            // Function to populate category dropdown
            function populateMasteryCategories() {
                if (!categorySelect) return;
                
                // Get all categories from items that can provide mastery
                const categories = [];
                items.forEach(item => {
                    if (item.providesMastery && item.category && !categories.includes(item.category)) {
                        categories.push(item.category);
                    }
                });
                
                // Sort categories
                categories.sort();
                
                // Clear existing options except "All"
                while (categorySelect.options.length > 1) {
                    categorySelect.remove(1);
                }
                
                // Add categories to select
                categories.forEach(category => {
                    const option = document.createElement('option');
                    option.value = category;
                    option.textContent = category;
                    categorySelect.appendChild(option);
                });
            }
            
            // Function to mark all items in a category as mastered/unmastered
            function markAllInCategoryAs(category, mastered) {
                const confirmMsg = mastered ? 
                    `Are you sure you want to mark ALL ${category === 'All' ? '' : category + ' '}items as MASTERED?` :
                    `Are you sure you want to mark ALL ${category === 'All' ? '' : category + ' '}items as UNMASTERED?`;
                    
                if (confirm(confirmMsg)) {
                    // Get all displayed items based on current filters
                    const displayedItems = getFilteredMasteryItems(category, searchInput ? searchInput.value : '');
                    
                    // Update mastery status for each item
                    displayedItems.forEach(item => {
                        if (item.providesMastery) {
                            inventory.masteredItems[item.name] = mastered;
                            item.mastered = mastered;
                        }
                    });
                    
                    // Save inventory and items data
                    saveInventory();
                    saveItems();
                    
                    // Update UI
                    renderMasteryItems();
                    updateMasteryProgress();
                }
            }
        }
        
        // Toggle mastery status for an item
        function toggleMastery(itemName, element) {
            // Find the item
            const itemIndex = items.findIndex(item => item.name === itemName);
            if (itemIndex === -1) return;
            
            const item = items[itemIndex];
            
            // If item doesn't provide mastery, show a message
            if (!item.providesMastery) {
                alert('This item does not provide mastery points.');
                return;
            }
            
            // Toggle mastery status in inventory
            inventory.masteredItems[itemName] = !inventory.masteredItems[itemName];
            
            // Also update mastery in the items array
            items[itemIndex].mastered = inventory.masteredItems[itemName];
            
            // Update the element appearance
            if (element) {
                if (inventory.masteredItems[itemName]) {
                    element.textContent = 'Mastered';
                    element.style.backgroundColor = '#28a745'; // Green
                } else {
                    element.textContent = 'Unmastered';
                    element.style.backgroundColor = '#dc3545'; // Red
                }
            }
            
            // Save to localStorage
            saveInventory();
            saveItems();
            
            // Update all mastery indicators
            updateAllMasteryIndicators(itemName);
            
            // Update mastery count
            updateMasteryCount();
            
            // If exclude-mastered is checked, refresh the filtered items
            const excludeMasteredCheckbox = document.getElementById('exclude-mastered');
            if (excludeMasteredCheckbox && excludeMasteredCheckbox.checked) {
                renderFilteredItems();
            }
            
            // Update calculator if there are selected items
            if (selectedItems.length > 0) {
                calculateTotals();
            }
        }
        
        // Update all mastery indicators for a given item
        function updateAllMasteryIndicators(itemName) {
            const isMastered = inventory.masteredItems[itemName] || false;
            
            // Update mastery indicators in the available items list
            document.querySelectorAll('.mastery-indicator').forEach(indicator => {
                // Check if this indicator belongs to the current item
                const parentEl = indicator.closest('.item-name, .selected-item-name, .resource-name');
                if (parentEl && parentEl.textContent.trim().indexOf(itemName) === 0) {
                    // Update text and color
                    indicator.textContent = isMastered ? 'Mastered' : 'Unmastered';
                    indicator.style.backgroundColor = isMastered ? '#28a745' : '#dc3545';
                }
            });
            
            // Update mastery status in the items table
            document.querySelectorAll('#itemsList tr').forEach(row => {
                const nameCell = row.querySelector('td:nth-child(2)');
                if (nameCell && nameCell.textContent.trim().indexOf(itemName) === 0) {
                    const statusSpan = nameCell.querySelector('.mastery-status');
                    if (statusSpan && !statusSpan.textContent.includes('No Mastery')) {
                        statusSpan.textContent = isMastered ? 'Mastered' : 'Not Mastered';
                        statusSpan.className = isMastered ? 
                            'mastery-status mastered' : 
                            'mastery-status not-mastered';
                    }
                }
            });
            
            // Update mastery items grid
            document.querySelectorAll('.mastery-checkbox').forEach(checkbox => {
                const input = checkbox.querySelector('input[data-item-name="' + itemName + '"]');
                if (input) {
                    input.checked = isMastered;
                    checkbox.className = isMastered ? 
                        'mastery-checkbox mastered' : 
                        'mastery-checkbox unmastered';
                    checkbox.innerHTML = checkbox.innerHTML.replace(/Mastered|Not Mastered/g, isMastered ? 'Mastered' : 'Not Mastered');
                }
            });
        }
        
        // Render mastery items based on filters
        function renderMasteryItems() {
            const container = document.getElementById('mastery-items-container');
            const categorySelect = document.getElementById('mastery-category-select');
            const searchInput = document.getElementById('mastery-search');
            
            if (!container) return;
            
            // Get filter values
            const category = categorySelect?.value || 'All';
            const searchTerm = searchInput?.value || '';
            
            // Get filtered items
            const filteredItems = getFilteredMasteryItems(category, searchTerm);
            
            // Clear container
            container.innerHTML = '';
            
            // Check if any items to display
            if (filteredItems.length === 0) {
                container.innerHTML = '<div class="empty-message">No items found matching your filters</div>';
                return;
            }
            
            // Create item elements
            filteredItems.forEach(item => {
                const isMastered = inventory.masteredItems[item.name] || false;
                
                const itemElement = document.createElement('div');
                itemElement.className = 'mastery-item';
                
                // Get proper image
                const imageUrl = item.image || 'https://via.placeholder.com/120?text=No+Image';
                
                // Create HTML for mastery item
                itemElement.innerHTML = `
                    <div class="mastery-item-image">
                        <img src="${imageUrl}" alt="${item.name}" onerror="this.onerror=null; this.src='https://via.placeholder.com/120?text=No+Image';">
                    </div>
                    <div class="mastery-item-details">
                        <div class="mastery-item-name">${item.name}</div>
                        <div class="mastery-item-category">${item.category || 'Uncategorized'}</div>
                        <label class="mastery-checkbox ${isMastered ? 'mastered' : 'unmastered'}">
                            <input type="checkbox" class="mastery-toggle" 
                                data-item-name="${item.name}" 
                                ${isMastered ? 'checked' : ''}>
                            ${isMastered ? 'Mastered' : 'Not Mastered'}
                        </label>
                    </div>
                `;
                
                // Add event listener for mastery toggle
                const checkbox = itemElement.querySelector('input.mastery-toggle');
                if (checkbox) {
                    checkbox.addEventListener('change', function() {
                        const itemName = this.getAttribute('data-item-name');
                        const isMastered = this.checked;
                        
                        // Update mastery status
                        toggleMastery(itemName, null);
                        
                        // Update checkbox label
                        const label = this.parentElement;
                        label.textContent = isMastered ? 'Mastered' : 'Not Mastered';
                        label.className = `mastery-checkbox ${isMastered ? 'mastered' : 'unmastered'}`;
                        
                        // Reappend the checkbox to the label (since we changed textContent)
                        label.prepend(checkbox);
                        
                        // Update mastery progress
                        updateMasteryProgress();
                    });
                }
                
                container.appendChild(itemElement);
            });
        }
        
        // Update mastery progress bar and counts
        function updateMasteryProgress() {
            const progressBar = document.getElementById('mastery-progress-bar');
            const masteryTotalCount = document.getElementById('mastery-total-count');
            const masteryAvailableCount = document.getElementById('mastery-available-count');
            
            if (!progressBar || !masteryTotalCount || !masteryAvailableCount) return;
            
            // Count all items that provide mastery
            let totalMasterable = 0;
            let totalMastered = 0;
            
            items.forEach(item => {
                if (item.providesMastery) {
                    totalMasterable++;
                    if (inventory.masteredItems[item.name]) {
                        totalMastered++;
                    }
                }
            });
            
            // Update counts
            masteryTotalCount.textContent = totalMastered;
            masteryAvailableCount.textContent = totalMasterable;
            
            // Update progress bar
            const percentage = totalMasterable > 0 ? (totalMastered / totalMasterable) * 100 : 0;
            progressBar.style.width = `${percentage}%`;
        }
        
        // Update mastery count
        function updateMasteryCount() {
            const masteryCountElement = document.getElementById('mastery-count');
            const totalItemsElement = document.getElementById('total-items');
            
            if (masteryCountElement && totalItemsElement) {
                // Count mastered items that provide mastery
                let masteredCount = 0;
                let totalItemsWithMastery = 0;
                
                items.forEach(item => {
                    if (item.providesMastery) {
                        totalItemsWithMastery++;
                        if (inventory.masteredItems[item.name]) {
                            masteredCount++;
                        }
                    }
                });
                
                masteryCountElement.textContent = masteredCount;
                totalItemsElement.textContent = totalItemsWithMastery;
            }
        }
        
        // Filter functions for mastery tracker
        function filterMasteryByCategory() {
            renderMasteryItems();
        }
        
        function filterMasteryBySearch() {
            renderMasteryItems();
        }
        
        function filterMasteryByStatus() {
            renderMasteryItems();
        }
        
        // Helper function to get filtered items
        function getFilteredMasteryItems(category, searchTerm) {
            // Get mastery status filter
            const masteryFilter = document.querySelector('input[name="mastery-filter"]:checked')?.value || 'all';
            
            return items.filter(item => {
                // Only include items that can provide mastery
                if (!item.providesMastery) return false;
                
                // Filter by category
                const matchesCategory = category === 'All' || item.category === category;
                
                // Filter by search term
                const matchesSearch = !searchTerm || 
                    item.name.toLowerCase().includes(searchTerm.toLowerCase());
                
                // Filter by mastery status
                const isMastered = inventory.masteredItems[item.name] || false;
                const matchesMasteryStatus = 
                    masteryFilter === 'all' || 
                    (masteryFilter === 'mastered' && isMastered) || 
                    (masteryFilter === 'unmastered' && !isMastered);
                
                return matchesCategory && matchesSearch && matchesMasteryStatus;
            });
        }
        
        /**************************
         * SORTING FUNCTIONS *
         **************************/
        function initializeSortButtons() {
            // Add sort button to Resources tab
            const sortResourcesBtn = document.getElementById('sortResourcesBtn');
            if (sortResourcesBtn) {
                sortResourcesBtn.addEventListener('click', sortResources);
            }
            
            // Add sort button to Items tab
            const sortItemsBtn = document.getElementById('sortItemsBtn');
            if (sortItemsBtn) {
                sortItemsBtn.addEventListener('click', sortItems);
            }
            
            // Add sort button to Inventory tab
            const sortInventoryBtn = document.getElementById('sortInventoryBtn');
            if (sortInventoryBtn) {
                sortInventoryBtn.addEventListener('click', sortInventory);
            }
        }
        
        // Function to determine star chart planets
        function isStarChartPlanet(location) {
            const starChartPlanets = [
                'Mercury', 'Venus', 'Earth', 'Lua', 'Mars', 'Deimos', 'Phobos', 
                'Ceres', 'Jupiter', 'Europa', 'Saturn', 'Uranus', 'Neptune', 
                'Pluto', 'Sedna', 'Eris', 'Kuva Fortress', 'Void'
            ];
            return starChartPlanets.includes(location);
        }
        
        // Get location sort priority
        function getLocationSortPriority(location) {
            // If it's a star chart location, return priority for "Star Chart"
            if (isStarChartPlanet(location)) {
                return 0; // Star Chart has highest priority
            }
            
            const locationOrder = [
                'Star Chart', 'Empyrean', 'Plains of Eidolon', 'Orb Vallis', 
                'Cambion Drift', 'Zariman', 'Duviri', 'Albrecht\'s Laboratories',
                'Höllvania', 'Miscellaneous'
            ];
            
            const index = locationOrder.indexOf(location);
            return index === -1 ? locationOrder.length : index;
        }
        
        // Get rarity sort priority
        function getRaritySortPriority(rarity) {
            const rarityOrder = [
                'Common', 'Uncommon', 'Rare', 'Research', 'Navigation', 'Sentient',
                'Bonds', 'Systems', 'Toroid', 'Residue', 'Tokens', 'Orokin Matrix',
                'Necramech', 'Mining', 'Fishing', 'Special', 'Plants', 'Hex Treasures',
                'Event', 'Quest', 'Syndicate', 'Narmer', 'Other'
            ];
            
            const index = rarityOrder.indexOf(rarity);
            return index === -1 ? rarityOrder.length : index;
        }
        
        // Get category sort priority for items
        function getCategorySortPriority(category) {
            const categoryOrder = [
                'Warframes', 'Archwings', 'Necramech', 'Primary Weapon', 
                'Secondary Weapon', 'Melee Weapon', 'Archgun', 'Arch-Melee', 
                'Sentinel', 'MOA', 'Infested Companion', 'Hound', 'Robotic Weapon', 
                'Amp', 'Zaw', 'Kitgun', 'K-Drive', 'Railjack', 'Cosmetic', 
                'Decoration', 'Gear', 'Component', 'Crafting', 'Syndicate', 'Quest', 'Other'
            ];
            
            const index = categoryOrder.indexOf(category);
            return index === -1 ? categoryOrder.length : index;
        }
        
        // Sort function for resources
        function sortResources() {
            // Sort resources by location first, then rarity
            resources.sort((a, b) => {
                // Get primary locations for comparison
                const locA = a.locations && a.locations.length > 0 ? a.locations[0] : '';
                const locB = b.locations && b.locations.length > 0 ? b.locations[0] : '';
                
                // Check if both are star chart planets
                const aIsStarChart = isStarChartPlanet(locA);
                const bIsStarChart = isStarChartPlanet(locB);
                
                // If both are star chart planets, compare by rarity
                if (aIsStarChart && bIsStarChart) {
                    // Compare by rarity
                    const rarityCompare = getRaritySortPriority(a.rarity) - getRaritySortPriority(b.rarity);
                    if (rarityCompare !== 0) return rarityCompare;
                    
                    // If rarity is the same, sort by name
                    return a.name.localeCompare(b.name);
                }
                
                // Compare by location priority
                const locationCompareA = getLocationSortPriority(aIsStarChart ? 'Star Chart' : locA);
                const locationCompareB = getLocationSortPriority(bIsStarChart ? 'Star Chart' : locB);
                
                if (locationCompareA !== locationCompareB) {
                    return locationCompareA - locationCompareB;
                }
                
                // Compare by rarity
                const rarityCompare = getRaritySortPriority(a.rarity) - getRaritySortPriority(b.rarity);
                if (rarityCompare !== 0) return rarityCompare;
                
                // If rarity is the same, sort by name
                return a.name.localeCompare(b.name);
            });
            
            // Save sorted resources and render
            saveResources();
            renderResources();
            
            // Also reinitialize the resource selection for items
            setTimeout(() => {
                reinitializeResourceSelection();
                
                // Dispatch an event to notify that resources have changed
                document.dispatchEvent(new CustomEvent('resourcesChanged'));
                
                // Show notification
                showSaveNotification('Resources sorted successfully!');
            }, 100);
        }
        
        // Sort function for items
        function sortItems() {
            // Sort items by category
            items.sort((a, b) => {
                // Compare by category priority
                const categoryA = a.category || 'Other';
                const categoryB = b.category || 'Other';
                
                const categoryCompare = getCategorySortPriority(categoryA) - getCategorySortPriority(categoryB);
                if (categoryCompare !== 0) return categoryCompare;
                
                // If category is the same, sort by name
                return a.name.localeCompare(b.name);
            });
            
            // Save sorted items and render
            saveItems();
            renderItems();
            
            // Show a temporary notification
            showSaveNotification('Items sorted successfully!');
        }
        
        // Function to sort both resources and items in inventory
        function sortInventory() {
            // No need to sort the actual data arrays again since they are already sorted
            // Just re-render the inventory with the current sorted data
            renderInventory();
            
            // Show a temporary notification
            showSaveNotification('Inventory display sorted!');
        }
        // Missing calculateTotals function
/**
 * Calculates the total resources, credits, and components needed for crafting selected items
 * 
 * This function handles:
 * 1. Determining components needed from all selected items
 * 2. Checking inventory for available items and resources
 * 3. Calculating blueprint and crafting costs
 * 4. Applying blueprint overrides from user selection
 * 5. Handling infinite-use and multi-item blueprints
 */
function calculateTotals() {
    // Initialize tracking variables
    let totalResources = {};    // Raw resource requirements
    let totalCredits = 0;       // Total credit cost
    let blueprintCredits = 0;   // Credits for blueprint purchases
    let buildCredits = 0;       // Credits for building items
    
    // Track which infinite-use blueprints have been counted
    const countedInfiniteBlueprints = new Set();
    
    // Track component items and their quantities for display
    let componentItems = {};
    
    // Copy inventory items to avoid modifying original
    let availableItems = {};
    for (const [itemName, quantity] of Object.entries(inventory.items)) {
        availableItems[itemName] = quantity;
    }
    
    // Create effective blueprints object that takes overrides into account
    let effectiveBlueprints = {};
    for (const [itemName, quantity] of Object.entries(inventory.blueprints)) {
        effectiveBlueprints[itemName] = quantity;
    }
    
    // Apply overrides from selected items
    selectedItems.forEach(selectedItem => {
        if (selectedItem.blueprintOverride !== null) {
            effectiveBlueprints[selectedItem.item.name] = selectedItem.blueprintOverride;
        }
    });
    
    // Apply overrides from component blueprints
    if (window.componentBlueprintOverrides) {
        for (const [itemName, quantity] of Object.entries(window.componentBlueprintOverrides)) {
            effectiveBlueprints[itemName] = quantity;
        }
    }
    
    /**
     * Recursively finds all components needed for an item and its subcomponents
     * @param {Object} item - The item object
     * @param {Number} quantity - How many of this item are needed
     * @param {Boolean} isRoot - Whether this is a root item (directly selected) or a component
     * @param {Array} path - Current dependency path to detect circular dependencies
     */
    function findAllComponents(item, quantity, isRoot = true, path = []) {
        if (!isRoot) {
            // Track component items (not root items)
            componentItems[item.name] = (componentItems[item.name] || 0) + quantity;
        }
        
        // Look for components in resources
        if (item.resources) {
            item.resources.forEach(resource => {
                // For resources that are actually items (components)
                let isItemResource = resource.type === 'item';
                if (!isItemResource && !resource.type) {
                    // For backward compatibility - check if this resource name exists in items array
                    isItemResource = items.some(i => i.name === resource.name);
                }
                
                if (isItemResource) {
                    const resourceName = resource.name;
                    const resourceItem = items.find(i => i.name === resourceName);
                    
                    if (resourceItem) {
                        // Calculate quantity needed
                        let resourceQuantity;
                        if (item.multiItemBlueprint) {
                            const itemsPerBlueprint = parseInt(item.itemsPerBlueprint) || 1;
                            const craftsNeeded = Math.ceil(quantity / itemsPerBlueprint);
                            resourceQuantity = parseInt(resource.quantity || 0) * craftsNeeded;
                        } else {
                            resourceQuantity = parseInt(resource.quantity || 0) * quantity;
                        }
                        
                        // Check for circular dependencies
                        if (!path.includes(resourceItem.name)) {
                            // Recursively find components of this component
                            findAllComponents(resourceItem, resourceQuantity, false, [...path, item.name]);
                        }
                    }
                }
            });
        }
    }
    
    // Process each selected item to find all components
    selectedItems.forEach(({ item, quantity }) => {
        findAllComponents(item, quantity);
    });
    
    // Calculate how many of each component we need to craft
    let craftingNeeded = {};
    for (const [itemName, totalNeeded] of Object.entries(componentItems)) {
        const availableQuantity = availableItems[itemName] || 0;
        
        if (availableQuantity >= totalNeeded) {
            // We have enough in inventory
            availableItems[itemName] -= totalNeeded;
            craftingNeeded[itemName] = 0;
        } else {
            // We need to craft some
            craftingNeeded[itemName] = totalNeeded - availableQuantity;
            availableItems[itemName] = 0; // Use all available
        }
    }
    
    /**
     * Calculates resources needed to craft a specific item
     * @param {Object} item - The item object
     * @param {Number} quantity - How many to craft
     * @param {Boolean} isRoot - Whether this is a root item or component
     */
    function calculateResourcesForItemDirectly(item, quantity, isRoot) {
        // Skip if nothing to craft
        if (quantity <= 0) return;
        
        // Calculate blueprints and crafts needed, accounting for available blueprints
        let blueprintsNeeded = 0;
        let craftsNeeded = 0;
        
        if (item.infiniteUses) {
            // For infinite-use blueprints
            if (!countedInfiniteBlueprints.has(item.name)) {
                // Check if player has this infinite blueprint
                const hasBlueprint = effectiveBlueprints[item.name] > 0;
                blueprintsNeeded = hasBlueprint ? 0 : 1;
                countedInfiniteBlueprints.add(item.name);
            } else {
                blueprintsNeeded = 0;
            }
            
            // Calculate crafts needed
            if (item.multiItemBlueprint) {
                const itemsPerBlueprint = parseInt(item.itemsPerBlueprint) || 1;
                craftsNeeded = Math.ceil(quantity / itemsPerBlueprint);
            } else {
                craftsNeeded = quantity;
            }
        } else if (item.multiItemBlueprint) {
            // For non-infinite multi-item blueprints
            const itemsPerBlueprint = parseInt(item.itemsPerBlueprint) || 1;
            const totalBlueprintsNeeded = Math.ceil(quantity / itemsPerBlueprint);
            
            // Check available blueprints
            const ownedBlueprints = effectiveBlueprints[item.name] || 0;
            if (ownedBlueprints >= totalBlueprintsNeeded) {
                // Use owned blueprints
                blueprintsNeeded = 0;
                effectiveBlueprints[item.name] -= totalBlueprintsNeeded;
            } else {
                // Use all owned and need to acquire the rest
                blueprintsNeeded = totalBlueprintsNeeded - ownedBlueprints;
                effectiveBlueprints[item.name] = 0;
            }
            
            craftsNeeded = totalBlueprintsNeeded;
        } else {
            // For regular single-use, single-item blueprints
            const totalBlueprintsNeeded = quantity;
            
            // Check available blueprints
            const ownedBlueprints = effectiveBlueprints[item.name] || 0;
            if (ownedBlueprints >= totalBlueprintsNeeded) {
                // Use owned blueprints
                blueprintsNeeded = 0;
                effectiveBlueprints[item.name] -= totalBlueprintsNeeded;
            } else {
                // Use all owned and need to acquire the rest
                blueprintsNeeded = totalBlueprintsNeeded - ownedBlueprints;
                effectiveBlueprints[item.name] = 0;
            }
            
            craftsNeeded = quantity;
        }
        
        // Add blueprint cost - only if we actually need to acquire blueprints
        if (item.blueprintCost && blueprintsNeeded > 0) {
            if (item.blueprintCost.type === "Credits") {
                const creditCost = parseInt(item.blueprintCost.quantity || 0) * blueprintsNeeded;
                blueprintCredits += creditCost;
            } else if (item.blueprintCost.type === "Resource") {
                // Get the resource name without prefixes
                let resourceName = item.blueprintCost.resource;
                if (resourceName.startsWith("resource:")) {
                    resourceName = resourceName.substring(9);
                } else if (resourceName.startsWith("item:")) {
                    resourceName = resourceName.substring(5);
                }
                
                const resourceQuantity = parseInt(item.blueprintCost.quantity || 0) * blueprintsNeeded;
                
                // Check if this is an item or a resource
                if (items.some(i => i.name === resourceName)) {
                    // This is an item - add to component items
                    componentItems[resourceName] = (componentItems[resourceName] || 0) + resourceQuantity;
                    
                    // Recalculate crafting needed for this component
                    const availableQuantity = availableItems[resourceName] || 0;
                    if (availableQuantity >= resourceQuantity) {
                        availableItems[resourceName] -= resourceQuantity;
                        craftingNeeded[resourceName] = 0;
                    } else {
                        craftingNeeded[resourceName] = resourceQuantity - availableQuantity;
                        availableItems[resourceName] = 0;
                    }
                } else {
                    // This is a raw resource
                    totalResources[resourceName] = (totalResources[resourceName] || 0) + resourceQuantity;
                }
            }
        }
        
        // Add build credit cost
        const buildCreditCost = parseInt(item.buildCreditCost || 0);
        if (item.multiItemBlueprint) {
            buildCredits += buildCreditCost * craftsNeeded;
        } else {
            buildCredits += buildCreditCost * quantity;
        }
        
        // Add direct raw resources (not component items)
        if (item.resources) {
            item.resources.forEach(resource => {
                // Check if this is an item resource
                let isItemResource = resource.type === 'item';
                if (!isItemResource && !resource.type) {
                    // For backward compatibility - check if this resource name exists in items array
                    isItemResource = items.some(i => i.name === resource.name);
                }
                
                if (!isItemResource) {
                    // This is a raw resource
                    let resourceQuantity;
                    if (item.multiItemBlueprint) {
                        resourceQuantity = parseInt(resource.quantity || 0) * craftsNeeded;
                    } else {
                        resourceQuantity = parseInt(resource.quantity || 0) * quantity;
                    }
                    
                    totalResources[resource.name] = (totalResources[resource.name] || 0) + resourceQuantity;
                }
                // Component items are handled separately
            });
        }
    }
    
    // First process the root items
    selectedItems.forEach(({ item, quantity }) => {
        calculateResourcesForItemDirectly(item, quantity, true);
    });
    
    // Then process the component hierarchy
    for (const [itemName, craftQuantity] of Object.entries(craftingNeeded)) {
        if (craftQuantity > 0) {
            const item = items.find(i => i.name === itemName);
            if (item) {
                calculateResourcesForItemDirectly(item, craftQuantity, false);
            }
        }
    }
    
    // Calculate total credits
    totalCredits = blueprintCredits + buildCredits;
    
    // Render results
    renderTotalResources(totalResources, totalCredits, blueprintCredits, buildCredits, componentItems);
}

// Function to add all unmastered items to calculator
function addUnmasteredToCalculator() {
    // Get current filters
    const categorySelect = document.getElementById('mastery-category-select');
    const searchInput = document.getElementById('mastery-search');
    
    const category = categorySelect?.value || 'All';
    const searchTerm = searchInput?.value || '';
    
    // Get filtered unmastered items
    const displayedItems = getFilteredMasteryItems(category, searchTerm);
    const unmasteredItems = displayedItems.filter(item => 
        item.providesMastery && !inventory.masteredItems[item.name]
    );
    
    if (unmasteredItems.length === 0) {
        alert('No unmastered items found matching your current filters.');
        return;
    }
    
    // Confirm with user
    if (confirm(`Add ${unmasteredItems.length} unmastered items to the calculator?`)) {
        // Clear current selection if wanted
        if (selectedItems.length > 0) {
            if (confirm('Clear current calculator selection before adding?')) {
                selectedItems = [];
            }
        }
        
        // Add each unmastered item to calculator
        unmasteredItems.forEach(item => {
            // Check if already in the calculator
            const existingIndex = selectedItems.findIndex(i => i.item.name === item.name);
            
            if (existingIndex >= 0) {
                // Increase quantity if already in list
                selectedItems[existingIndex].quantity += 1;
            } else {
                // Add new item with quantity 1
                selectedItems.push({ item, quantity: 1 });
            }
        });
        
        // Show success message
        alert(`Added ${unmasteredItems.length} unmastered items to the calculator!`);
        
        // Switch to calculator tab
        const calculatorTab = document.querySelector('.tab[data-tab="calculator"]');
        if (calculatorTab) {
            calculatorTab.click();
        }
    }
}

// Fixed and enhanced format function for blueprint sources with condensed option
function formatDetailedBlueprintSources(item, condensed = false) {
    // Check if item has blueprint sources in the new format
    if (item.blueprintSources && item.blueprintSources.length > 0) {
        // For condensed view, show first source with a toggle
        if (condensed) {
            const firstSource = item.blueprintSources[0];
            const hasMoreSources = item.blueprintSources.length > 1;
            
            let html = `
                <div class="calculator-source">
                    <div class="calculator-source-entry ${getSourceTypeClass(firstSource.type)}">
                        <div class="calculator-source-type">${firstSource.type}</div>
                        ${formatSourceDetails(firstSource)}
                    </div>
            `;
            
            if (hasMoreSources) {
                html += `
                    <button class="source-toggle-btn" onclick="toggleAdditionalSources(this)">
                        Show ${item.blueprintSources.length - 1} more sources
                    </button>
                    <div class="additional-sources" style="display: none;">
                `;
                
                // Add remaining sources
                for (let i = 1; i < item.blueprintSources.length; i++) {
                    const source = item.blueprintSources[i];
                    html += `
                        <div class="calculator-source-entry ${getSourceTypeClass(source.type)}">
                            <div class="calculator-source-type">${source.type}</div>
                            ${formatSourceDetails(source)}
                        </div>
                    `;
                }
                
                html += `</div>`;
            }
            
            html += `</div>`;
            return html;
        } 
        // For full view, show all sources
        else {
            return `
                <div class="calculator-source">
                    ${item.blueprintSources.map(source => {
                        return `
                            <div class="calculator-source-entry ${getSourceTypeClass(source.type)}">
                                <div class="calculator-source-type">${source.type}</div>
                                ${formatSourceDetails(source)}
                            </div>
                        `;
                    }).join('')}
                </div>
            `;
        }
    } 
    // Backward compatibility with old format
    else if (item.blueprintSource) {
        return `<div class="calculator-source-legacy">${item.blueprintSource}</div>`;
    } 
    // No source info
    else {
        return '<div class="calculator-source-none">None</div>';
    }
}



// Fixed enhanced renderSelectedItems function
function renderSelectedItems() {
    const selectedItemsElement = document.getElementById('selected-items');
    
    if (!selectedItemsElement) return;
    
    if (selectedItems.length === 0) {
        selectedItemsElement.innerHTML = '<div class="empty-message">No items selected</div>';
        return;
    }
    
    selectedItemsElement.innerHTML = '';
    
    selectedItems.forEach((selectedItem, index) => {
        const item = selectedItem.item;
        const quantity = selectedItem.quantity;
        
        // Initialize blueprint override if not set
        if (selectedItem.blueprintOverride === undefined) {
            selectedItem.blueprintOverride = null; // null means use inventory value
        }
        
        // Check if item is mastered and provides mastery
        const isMastered = inventory.masteredItems[item.name] || false;
        const providesMastery = item.providesMastery || false;
        
        // Calculate effective blueprint count - use override if set, otherwise use inventory
        const ownedBlueprints = selectedItem.blueprintOverride !== null ? 
            selectedItem.blueprintOverride : 
            (inventory.blueprints[item.name] || 0);
        
        const hasBlueprint = ownedBlueprints > 0;
        
        // Get the item image URL
        const itemImage = item.image || '';
        
        let masteryHTML = '';
        if (providesMastery) {
            masteryHTML = `
                <span class="mastery-indicator" style="margin-left: 5px; font-size: 12px; padding: 2px 6px; border-radius: 10px; cursor: pointer; background-color: ${isMastered ? '#28a745' : '#dc3545'}; color: white;" 
                      onclick="toggleMastery('${item.name.replace(/'/g, "\\'")}', this)">
                    ${isMastered ? 'Mastered' : 'Unmastered'}
                </span>
            `;
        }
        
        // Determine blueprint status text - creating unique IDs for dynamic updates
        const blueprintStatusId = `blueprint-status-${index}`;
        let blueprintStatus = '';
        let blueprintsNeeded = 0;
        let craftsNeeded = 0;
        
        if (item.infiniteUses) {
            // For infinite-use blueprints
            if (hasBlueprint) {
                blueprintStatus = '<span style="color: purple;">Have infinite-use blueprint</span>';
                blueprintsNeeded = 0;
            } else {
                blueprintStatus = '<span style="color: purple;">Need to acquire infinite-use blueprint</span>';
                blueprintsNeeded = 1;
            }
            
            // Calculate crafts needed for infinite-use blueprints
            if (item.multiItemBlueprint) {
                const itemsPerBlueprint = parseInt(item.itemsPerBlueprint) || 1;
                craftsNeeded = Math.ceil(quantity / itemsPerBlueprint);
                const totalCrafted = craftsNeeded * itemsPerBlueprint;
                const extraItems = totalCrafted - quantity;
                
                blueprintStatus += `<div style="margin-top: 3px; font-size: 12px; color: blue;">
                    Need ${craftsNeeded} craft${craftsNeeded > 1 ? 's' : ''} (${itemsPerBlueprint} items per craft)
                </div>`;
                
                if (extraItems > 0) {
                    blueprintStatus += `<div style="font-size: 12px;">Will craft ${totalCrafted} items total
                        <span style="color: #17a2b8; margin-left: 5px;">(+${extraItems} extra)</span>
                    </div>`;
                }
            } else {
                craftsNeeded = quantity;
                blueprintStatus += `<div style="margin-top: 3px; font-size: 12px;">
                    Need ${craftsNeeded} craft${craftsNeeded > 1 ? 's' : ''}
                </div>`;
            }
        } else if (item.multiItemBlueprint) {
            // For non-infinite multi-item blueprints
            const itemsPerBlueprint = parseInt(item.itemsPerBlueprint) || 1;
            const totalBlueprintsNeeded = Math.ceil(quantity / itemsPerBlueprint);
            
            if (ownedBlueprints >= totalBlueprintsNeeded) {
                blueprintStatus = `<span style="color: green;">Have all ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''} needed</span>`;
                blueprintsNeeded = 0;
            } else if (ownedBlueprints > 0) {
                const neededMore = totalBlueprintsNeeded - ownedBlueprints;
                blueprintStatus = `<span>Have ${ownedBlueprints}, need ${neededMore} more blueprint${neededMore > 1 ? 's' : ''}</span>`;
                blueprintsNeeded = neededMore;
            } else {
                blueprintStatus = `<span>Need ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''}</span>`;
                blueprintsNeeded = totalBlueprintsNeeded;
            }
            
            craftsNeeded = totalBlueprintsNeeded;
            const totalCrafted = craftsNeeded * itemsPerBlueprint;
            const extraItems = totalCrafted - quantity;
            
            // Show total crafted and extras
            blueprintStatus += `<div style="margin-top: 3px; font-size: 12px;">Will craft ${totalCrafted} items total`;
            if (extraItems > 0) {
                blueprintStatus += `<span style="color: #17a2b8; margin-left: 5px;">(+${extraItems} extra)</span>`;
            }
            blueprintStatus += `</div>`;
        } else {
            // For regular single-use, single-item blueprints
            const totalBlueprintsNeeded = quantity;
            
            if (ownedBlueprints >= totalBlueprintsNeeded) {
                blueprintStatus = `<span style="color: green;">Have all ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''} needed</span>`;
                blueprintsNeeded = 0;
            } else if (ownedBlueprints > 0) {
                const neededMore = totalBlueprintsNeeded - ownedBlueprints;
                blueprintStatus = `<span>Have ${ownedBlueprints}, need ${neededMore} more blueprint${neededMore > 1 ? 's' : ''}</span>`;
                blueprintsNeeded = neededMore;
            } else {
                blueprintStatus = `<span>Need ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''}</span>`;
                blueprintsNeeded = totalBlueprintsNeeded;
            }
            
            craftsNeeded = quantity;
        }
        
        // Additional info text
        let blueprintInfoText = '';
        if (item.infiniteUses && item.multiItemBlueprint) {
            blueprintInfoText += '<div style="color: purple;">(Infinite-use blueprint that creates multiple items)</div>';
        } else if (item.infiniteUses) {
            blueprintInfoText += '<div style="color: purple;">(Blueprint has infinite uses)</div>';
        } else if (item.multiItemBlueprint) {
            blueprintInfoText += `<div style="color: blue;">(Creates ${item.itemsPerBlueprint} items per blueprint)</div>`;
        }
        
        // Calculate costs for this item - with a unique ID for dynamic updates
        const blueprintCostId = `blueprint-cost-${index}`;
        let itemBlueprintCredits = 0;
        let itemBlueprintResourceText = '';
        
        if (item.blueprintCost && blueprintsNeeded > 0) {
            if (item.blueprintCost.type === "Credits") {
                const costPerBlueprint = parseInt(item.blueprintCost.quantity || 0);
                itemBlueprintCredits = costPerBlueprint * blueprintsNeeded;
                itemBlueprintResourceText = `<div class="selected-item-cost">Blueprint: ${itemBlueprintCredits.toLocaleString()} credits (${blueprintsNeeded} × ${costPerBlueprint.toLocaleString()})</div>`;
            } else if (item.blueprintCost.type === "Resource") {
                // Extract the actual resource name
                let resourceName = item.blueprintCost.resource;
                if (resourceName.startsWith("resource:")) {
                    resourceName = resourceName.substring(9);
                } else if (resourceName.startsWith("item:")) {
                    resourceName = resourceName.substring(5);
                }
                
                const costPerBlueprint = parseInt(item.blueprintCost.quantity || 0);
                const resourceCost = costPerBlueprint * blueprintsNeeded;
                itemBlueprintResourceText = `<div class="selected-item-cost">Blueprint: ${resourceCost.toLocaleString()} ${resourceName} (${blueprintsNeeded} × ${costPerBlueprint.toLocaleString()})</div>`;
            } else if (item.blueprintCost.type === "Standing") {
                const costPerBlueprint = parseInt(item.blueprintCost.quantity || 0);
                const standingCost = costPerBlueprint * blueprintsNeeded;
                itemBlueprintResourceText = `<div class="selected-item-cost">Blueprint: ${standingCost.toLocaleString()} Standing (${blueprintsNeeded} × ${costPerBlueprint.toLocaleString()})</div>`;
            }
        } else if (item.blueprintCost) {
            // We have all the blueprints we need
            itemBlueprintResourceText = `<div class="selected-item-cost"><em>(using existing blueprints)</em></div>`;
        } else {
            itemBlueprintResourceText = `<div class="selected-item-cost"><em>(no blueprint cost)</em></div>`;
        }
        
        // Build costs should be based on actual quantity requested
        let buildCostDisplay = '';
        let itemBuildCredits = 0;
        
        if (item.multiItemBlueprint) {
            // For multi-item blueprints, calculate based on crafts needed
            const costPerCraft = parseInt(item.buildCreditCost || 0);
            itemBuildCredits = costPerCraft * craftsNeeded;
            
            // Display showing the calculation
            buildCostDisplay = `<div class="selected-item-cost">Build: ${itemBuildCredits.toLocaleString()} credits (${craftsNeeded} craft${craftsNeeded > 1 ? 's' : ''} × ${costPerCraft.toLocaleString()})</div>`;
        } else {
            // For regular items, cost is per item
            const costPerItem = parseInt(item.buildCreditCost || 0);
            itemBuildCredits = costPerItem * quantity;
            buildCostDisplay = `<div class="selected-item-cost">Build: ${itemBuildCredits.toLocaleString()} credits</div>`;
        }
        
        const itemTotalCredits = itemBlueprintCredits + itemBuildCredits;
        
        // Create blueprint input form based on blueprint type
        let blueprintInputHTML = '';
        if (item.infiniteUses) {
            // For infinite-use blueprints - checkbox
            const checkedAttr = ownedBlueprints > 0 ? 'checked' : '';
            blueprintInputHTML = `
                <div class="blueprint-checkbox" style="margin-top: 10px; padding: 5px; background-color: #f8f9fa; border-radius: 4px;">
                    <input type="checkbox" id="calc-bp-${index}" ${checkedAttr} 
                        onchange="updateCalculatorBlueprintStatus(${index}, this.checked); updateBlueprintDisplay(${index});">
                    <label for="calc-bp-${index}">I have this blueprint</label>
                </div>
            `;
        } else {
            // For single-use blueprints - number input
            blueprintInputHTML = `
                <div class="blueprint-input" style="margin-top: 10px; padding: 5px; background-color: #f8f9fa; border-radius: 4px; display: flex; align-items: center;">
                    <label for="calc-bp-qty-${index}" style="margin-right: 5px;">Blueprints owned:</label>
                    <input type="number" id="calc-bp-qty-${index}" class="blueprint-quantity-input" 
                        value="${ownedBlueprints}" min="0" 
                        style="width: 70px; text-align: center;"
                        onchange="updateCalculatorBlueprintQuantity(${index}, this.value); updateBlueprintDisplay(${index});">
                </div>
            `;
        }
        
        // Add detailed blueprint source information with collapsible section
        const blueprintSourceCollapsibleId = `blueprint-source-collapsible-${index}`;
        const blueprintSourceHTML = `
            <div style="margin-top: 10px;">
                <button class="collapsible-btn" 
                        style="width: 100%; text-align: left; padding: 8px; background-color: #f0f0f0; border: none; cursor: pointer; border-radius: 4px; display: flex; justify-content: space-between; align-items: center;"
                        onclick="toggleCollapsible('${blueprintSourceCollapsibleId}')">
                    <span style="font-weight: 500;">Blueprint Source</span>
                    <span class="toggle-icon">▼</span>
                </button>
                <div id="${blueprintSourceCollapsibleId}" style="display: none; padding: 10px; border: 1px solid #eee; border-top: none; margin-bottom: 10px;">
                    ${formatDetailedBlueprintSources(item)}
                </div>
            </div>
        `;
        
        // Create details collapsible content
        const detailsCollapsibleId = `item-details-collapsible-${index}`;
        
        const itemElement = document.createElement('div');
        itemElement.className = 'selected-item';
        
        // Create detailed item display with image and collapsible details
        let itemHtml = `
            <div style="display: flex; gap: 15px; align-items: flex-start; width: 100%;">
                <div class="resource-img" style="width: 48px; height: 48px; flex-shrink: 0; border-radius: 50%; overflow: hidden; border: 1px solid #ddd; display: flex; justify-content: center; align-items: center; background-color: #f5f5f5; margin-top: 5px;">
                    ${itemImage ? 
                        `<img src="${itemImage}" alt="${item.name}" style="width: 100%; height: 100%; object-fit: contain;" onerror="this.onerror=null; this.src='https://via.placeholder.com/48'; this.style.opacity=0.5;">` : 
                        '<span style="font-size: 24px;">🔨</span>'}
                </div>
                <div style="flex-grow: 1;">
                    <div class="selected-item-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <div class="selected-item-name" style="font-size: 16px; font-weight: 600;">
                                ${item.name}
                                ${masteryHTML}
                            </div>
                            <div class="selected-item-category" style="font-size: 12px; color: #666;">${item.category || ''}</div>
                        </div>
                        <button class="collapsible-btn" 
                                style="background-color: #f0f0f0; border: none; cursor: pointer; border-radius: 4px; padding: 5px 10px; display: flex; align-items: center; gap: 5px;"
                                onclick="toggleCollapsible('${detailsCollapsibleId}')">
                            <span>Details</span>
                            <span class="toggle-icon">▼</span>
                        </button>
                    </div>
                    
                    <div id="${detailsCollapsibleId}" style="display: none; margin-top: 10px;">
                        <div class="selected-item-details">
                            <div class="selected-item-blueprint" id="${blueprintStatusId}">
                                ${blueprintStatus}
                                ${blueprintInfoText}
                            </div>
                            ${blueprintInputHTML}
                            ${blueprintSourceHTML}
                            <div id="${blueprintCostId}">
                                ${itemBlueprintResourceText}
                                ${buildCostDisplay}
                                <div class="selected-item-total">Total: ${itemTotalCredits.toLocaleString()} credits</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>`;
        
        itemElement.innerHTML = `
            <div class="selected-item-content" style="display: flex; flex-direction: column; width: 100%;">
                ${itemHtml}
                <div class="selected-item-controls" style="align-self: flex-end; margin-top: 10px;">
                    <div class="quantity-control">
                        <button onclick="updateItemQuantity(${index}, ${quantity - 1})">-</button>
                        <span class="quantity-display">${quantity}</span>
                        <button onclick="updateItemQuantity(${index}, ${quantity + 1})">+</button>
                        <button class="btn-remove" onclick="removeItemFromCalculator(${index})">Remove</button>
                    </div>
                </div>
            </div>
        `;
        selectedItemsElement.appendChild(itemElement);
    });
}

// Function to toggle collapsible sections
function toggleCollapsible(id) {
    const element = document.getElementById(id);
    if (!element) return;
    
    // Toggle the display of the element
    const isCurrentlyVisible = element.style.display !== 'none';
    element.style.display = isCurrentlyVisible ? 'none' : 'block';
    
    // Toggle the arrow icon in the button
    const button = document.querySelector(`button[onclick="toggleCollapsible('${id}')"]`);
    if (button) {
        const icon = button.querySelector('.toggle-icon');
        if (icon) {
            icon.textContent = isCurrentlyVisible ? '▼' : '▲';
        }
    }
}

// Add this CSS to your style section
const collapsibleStyles = `
.collapsible-btn {
    transition: background-color 0.3s;
}

.collapsible-btn:hover {
    background-color: #e0e0e0 !important;
}

.toggle-icon {
    font-size: 12px;
    transition: transform 0.3s;
}

.selected-item {
    margin-bottom: 15px;
    border: 1px solid #e0e0e0;
    border-radius: 8px;
    padding: 15px;
    background-color: white;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}
`;

// Function to add the CSS styles
function addCollapsibleStyles() {
    // Check if styles have already been added
    if (document.getElementById('collapsible-styles')) return;
    
    const styleElement = document.createElement('style');
    styleElement.id = 'collapsible-styles';
    styleElement.textContent = collapsibleStyles;
    document.head.appendChild(styleElement);
}

// Call this when the page loads
document.addEventListener('DOMContentLoaded', addCollapsibleStyles);

// Make sure to add styles immediately if script runs after page load
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    addCollapsibleStyles();
}

// New function to update blueprint display without re-rendering everything
function updateBlueprintDisplay(index) {
    const selectedItem = selectedItems[index];
    if (!selectedItem) return;
    
    const item = selectedItem.item;
    const quantity = selectedItem.quantity;
    
    // Get the blueprint status and cost elements
    const blueprintStatusEl = document.getElementById(`blueprint-status-${index}`);
    const blueprintCostEl = document.getElementById(`blueprint-cost-${index}`);
    
    if (!blueprintStatusEl || !blueprintCostEl) return;
    
    // Calculate effective blueprint count
    const ownedBlueprints = selectedItem.blueprintOverride !== null ? 
        selectedItem.blueprintOverride : 
        (inventory.blueprints[item.name] || 0);
    
    const hasBlueprint = ownedBlueprints > 0;
    
    // Update blueprint status text
    let blueprintStatus = '';
    let blueprintsNeeded = 0;
    let craftsNeeded = 0;
    
    if (item.infiniteUses) {
        // For infinite-use blueprints
        if (hasBlueprint) {
            blueprintStatus = '<span style="color: purple;">Have infinite-use blueprint</span>';
            blueprintsNeeded = 0;
        } else {
            blueprintStatus = '<span style="color: purple;">Need to acquire infinite-use blueprint</span>';
            blueprintsNeeded = 1;
        }
        
        // Calculate crafts needed
        if (item.multiItemBlueprint) {
            const itemsPerBlueprint = parseInt(item.itemsPerBlueprint) || 1;
            craftsNeeded = Math.ceil(quantity / itemsPerBlueprint);
            const totalCrafted = craftsNeeded * itemsPerBlueprint;
            const extraItems = totalCrafted - quantity;
            
            blueprintStatus += `<div style="margin-top: 3px; font-size: 12px; color: blue;">
                Need ${craftsNeeded} craft${craftsNeeded > 1 ? 's' : ''} (${itemsPerBlueprint} items per craft)
            </div>`;
            
            if (extraItems > 0) {
                blueprintStatus += `<div style="font-size: 12px;">Will craft ${totalCrafted} items total
                    <span style="color: #17a2b8; margin-left: 5px;">(+${extraItems} extra)</span>
                </div>`;
            }
        } else {
            craftsNeeded = quantity;
            blueprintStatus += `<div style="margin-top: 3px; font-size: 12px;">
                Need ${craftsNeeded} craft${craftsNeeded > 1 ? 's' : ''}
            </div>`;
        }
    } else if (item.multiItemBlueprint) {
        // For non-infinite multi-item blueprints
        const itemsPerBlueprint = parseInt(item.itemsPerBlueprint) || 1;
        const totalBlueprintsNeeded = Math.ceil(quantity / itemsPerBlueprint);
        
        if (ownedBlueprints >= totalBlueprintsNeeded) {
            blueprintStatus = `<span style="color: green;">Have all ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''} needed</span>`;
            blueprintsNeeded = 0;
        } else if (ownedBlueprints > 0) {
            const neededMore = totalBlueprintsNeeded - ownedBlueprints;
            blueprintStatus = `<span>Have ${ownedBlueprints}, need ${neededMore} more blueprint${neededMore > 1 ? 's' : ''}</span>`;
            blueprintsNeeded = neededMore;
        } else {
            blueprintStatus = `<span>Need ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''}</span>`;
            blueprintsNeeded = totalBlueprintsNeeded;
        }
        
        craftsNeeded = totalBlueprintsNeeded;
        const totalCrafted = craftsNeeded * itemsPerBlueprint;
        const extraItems = totalCrafted - quantity;
        
        // Show total crafted and extras
        blueprintStatus += `<div style="margin-top: 3px; font-size: 12px;">Will craft ${totalCrafted} items total`;
        if (extraItems > 0) {
            blueprintStatus += `<span style="color: #17a2b8; margin-left: 5px;">(+${extraItems} extra)</span>`;
        }
        blueprintStatus += `</div>`;
    } else {
        // For regular single-use, single-item blueprints
        const totalBlueprintsNeeded = quantity;
        
        if (ownedBlueprints >= totalBlueprintsNeeded) {
            blueprintStatus = `<span style="color: green;">Have all ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''} needed</span>`;
            blueprintsNeeded = 0;
        } else if (ownedBlueprints > 0) {
            const neededMore = totalBlueprintsNeeded - ownedBlueprints;
            blueprintStatus = `<span>Have ${ownedBlueprints}, need ${neededMore} more blueprint${neededMore > 1 ? 's' : ''}</span>`;
            blueprintsNeeded = neededMore;
        } else {
            blueprintStatus = `<span>Need ${totalBlueprintsNeeded} blueprint${totalBlueprintsNeeded > 1 ? 's' : ''}</span>`;
            blueprintsNeeded = totalBlueprintsNeeded;
        }
        
        craftsNeeded = quantity;
    }
    
    // Additional info text
    let blueprintInfoText = '';
    if (item.infiniteUses && item.multiItemBlueprint) {
        blueprintInfoText += '<div style="color: purple;">(Infinite-use blueprint that creates multiple items)</div>';
    } else if (item.infiniteUses) {
        blueprintInfoText += '<div style="color: purple;">(Blueprint has infinite uses)</div>';
    } else if (item.multiItemBlueprint) {
        blueprintInfoText += `<div style="color: blue;">(Creates ${item.itemsPerBlueprint} items per blueprint)</div>`;
    }
    
    // Update the blueprint status element
    blueprintStatusEl.innerHTML = `${blueprintStatus}${blueprintInfoText}`;
    
    // Calculate costs for this item
    let itemBlueprintCredits = 0;
    let itemBlueprintResourceText = '';
    
    if (item.blueprintCost && blueprintsNeeded > 0) {
        if (item.blueprintCost.type === "Credits") {
            const costPerBlueprint = parseInt(item.blueprintCost.quantity || 0);
            itemBlueprintCredits = costPerBlueprint * blueprintsNeeded;
            itemBlueprintResourceText = `<div class="selected-item-cost">Blueprint: ${itemBlueprintCredits.toLocaleString()} credits (${blueprintsNeeded} × ${costPerBlueprint.toLocaleString()})</div>`;
        } else if (item.blueprintCost.type === "Resource") {
            // Extract the actual resource name
            let resourceName = item.blueprintCost.resource;
            if (resourceName.startsWith("resource:")) {
                resourceName = resourceName.substring(9);
            } else if (resourceName.startsWith("item:")) {
                resourceName = resourceName.substring(5);
            }
            
            const costPerBlueprint = parseInt(item.blueprintCost.quantity || 0);
            const resourceCost = costPerBlueprint * blueprintsNeeded;
            itemBlueprintResourceText = `<div class="selected-item-cost">Blueprint: ${resourceCost.toLocaleString()} ${resourceName} (${blueprintsNeeded} × ${costPerBlueprint.toLocaleString()})</div>`;
        } else if (item.blueprintCost.type === "Standing") {
            const costPerBlueprint = parseInt(item.blueprintCost.quantity || 0);
            const standingCost = costPerBlueprint * blueprintsNeeded;
            itemBlueprintResourceText = `<div class="selected-item-cost">Blueprint: ${standingCost.toLocaleString()} Standing (${blueprintsNeeded} × ${costPerBlueprint.toLocaleString()})</div>`;
        }
    } else if (item.blueprintCost) {
        // We have all the blueprints we need
        itemBlueprintResourceText = `<div class="selected-item-cost"><em>(using existing blueprints)</em></div>`;
    } else {
        itemBlueprintResourceText = `<div class="selected-item-cost"><em>(no blueprint cost)</em></div>`;
    }
    
    // Build costs should be based on actual quantity requested
    let buildCostDisplay = '';
    let itemBuildCredits = 0;
    
    if (item.multiItemBlueprint) {
        // For multi-item blueprints, calculate based on crafts needed
        const costPerCraft = parseInt(item.buildCreditCost || 0);
        itemBuildCredits = costPerCraft * craftsNeeded;
        
        // Display showing the calculation
        buildCostDisplay = `<div class="selected-item-cost">Build: ${itemBuildCredits.toLocaleString()} credits (${craftsNeeded} craft${craftsNeeded > 1 ? 's' : ''} × ${costPerCraft.toLocaleString()})</div>`;
    } else {
        // For regular items, cost is per item
        const costPerItem = parseInt(item.buildCreditCost || 0);
        itemBuildCredits = costPerItem * quantity;
        buildCostDisplay = `<div class="selected-item-cost">Build: ${itemBuildCredits.toLocaleString()} credits</div>`;
    }
    
    const itemTotalCredits = itemBlueprintCredits + itemBuildCredits;
    
    // Update the blueprint cost element
    blueprintCostEl.innerHTML = `
        ${itemBlueprintResourceText}
        ${buildCostDisplay}
        <div class="selected-item-total">Total: ${itemTotalCredits.toLocaleString()} credits</div>
    `;
}
// Add this to your script.js file or in a <script> tag at the end of your HTML

// 1. Track current category and subcategory
let currentItemCategory = 'All';
let currentItemSubcategory = 'All';

// 2. Initialize category tabs functionality
function initializeItemCategoryTabs() {
    console.log("Initializing item category tabs");
    
    // Ensure our global state variables are defined
    window.currentItemCategory = 'All';
    window.currentItemSubcategory = 'All';
    
    // First, attach handlers to the main category tabs
    const mainTabs = document.querySelectorAll('.item-category-tab');
    console.log(`Found ${mainTabs.length} main category tabs`);
    
    mainTabs.forEach(tab => {
        // Create a new tab to replace the old one (to clear any previous event listeners)
        const newTab = tab.cloneNode(true);
        tab.parentNode.replaceChild(newTab, tab);
        
        // Add click handler to the new tab
        newTab.addEventListener('click', function(e) {
            e.preventDefault();
            const category = this.getAttribute('data-category');
            console.log(`Main category tab clicked: ${category}`);
            
            // Update UI - set all tabs inactive first
            document.querySelectorAll('.item-category-tab').forEach(t => {
                t.classList.remove('active');
                t.style.backgroundColor = '#e0e0e0';
                t.style.color = '#333';
            });
            
            // Make clicked tab active
            this.classList.add('active');
            this.style.backgroundColor = '#4a7de9';
            this.style.color = 'white';
            
            // Hide all subcategory tab groups first
            document.querySelectorAll('.item-subcategory-tabs').forEach(group => {
                group.style.display = 'none';
            });
            
            // Show relevant subcategory tab group based on selection
            let subcategoryContainer = null;
            
            if (category === 'Vehicles') {
                subcategoryContainer = document.querySelector('.vehicle-tabs');
            } else if (category === 'Weapons') {
                subcategoryContainer = document.querySelector('.weapon-tabs');
            } else if (category === 'Companions') {
                subcategoryContainer = document.querySelector('.companion-tabs');
            }
            
            // If we found a relevant container, show it and select the "All" tab
            if (subcategoryContainer) {
                console.log(`Showing subcategory container for ${category}`);
                subcategoryContainer.style.display = 'flex';
                
                // Reset all tabs in this container
                subcategoryContainer.querySelectorAll('.item-subcategory-tab').forEach(t => {
                    t.classList.remove('active');
                    t.style.backgroundColor = '#e0e0e0';
                    t.style.color = '#333';
                });
                
                // Find and activate the "All" tab
                const allTab = subcategoryContainer.querySelector('.item-subcategory-tab[data-subcategory="All"]');
                if (allTab) {
                    allTab.classList.add('active');
                    allTab.style.backgroundColor = '#4a7de9';
                    allTab.style.color = 'white';
                }
                
                // Update state
                window.currentItemSubcategory = 'All';
            } else {
                // If no subcategory, just reset to 'All'
                window.currentItemSubcategory = 'All';
            }
            
            // Update our state
            window.currentItemCategory = category;
            
            // Apply the filters
            applyItemFilters();
        });
    });
    
    // Similarly handle subcategory tabs
    const subTabs = document.querySelectorAll('.item-subcategory-tab');
    console.log(`Found ${subTabs.length} subcategory tabs`);
    
    subTabs.forEach(tab => {
        // Create a new tab to replace the old one
        const newTab = tab.cloneNode(true);
        tab.parentNode.replaceChild(newTab, tab);
        
        // Add click handler to the new tab
        newTab.addEventListener('click', function(e) {
            e.preventDefault();
            const subcategory = this.getAttribute('data-subcategory');
            console.log(`Subcategory tab clicked: ${subcategory}`);
            
            // Find the parent tab set
            const parentTabSet = this.closest('.item-subcategory-tabs');
            if (!parentTabSet) return;
            
            // Update active state within this tab set only
            parentTabSet.querySelectorAll('.item-subcategory-tab').forEach(t => {
                t.classList.remove('active');
                t.style.backgroundColor = '#e0e0e0';
                t.style.color = '#333';
            });
            
            // Set this tab as active
            this.classList.add('active');
            this.style.backgroundColor = '#4a7de9';
            this.style.color = 'white';
            
            // Update state
            window.currentItemSubcategory = subcategory;
            
            // Apply filters
            applyItemFilters();
        });
    });
    
    // Initial visibility setup - hide all subcategory tabs initially
    document.querySelectorAll('.item-subcategory-tabs').forEach(container => {
        container.style.display = 'none';
    });
    
    // Force first filter application if we're on the inventory tab
    if (document.querySelector('.tab[data-tab="inventory"]').classList.contains('active')) {
        setTimeout(() => {
            applyItemFilters();
        }, 200);
    }
    
    window.itemTabsInitialized = true;
}

function handleMainCategoryChange(category, clickedTab) {
    // Update UI - set all tabs inactive first
    document.querySelectorAll('.item-category-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
    });
    
    // Make clicked tab active
    clickedTab.classList.add('active');
    clickedTab.style.backgroundColor = '#4a7de9';
    clickedTab.style.color = 'white';
    
    // Hide all subcategory tab groups first
    document.querySelectorAll('.item-subcategory-tabs').forEach(group => {
        group.style.display = 'none';
    });
    
    // Show relevant subcategory tab group based on selection
    let subcategoryContainer = null;
    
    if (category === 'Vehicles') {
        subcategoryContainer = document.querySelector('.vehicle-tabs');
    } else if (category === 'Weapons') {
        subcategoryContainer = document.querySelector('.weapon-tabs');
    } else if (category === 'Companions') {
        subcategoryContainer = document.querySelector('.companion-tabs');
    }
    
    // If we found a relevant container, show it and select the "All" tab
    if (subcategoryContainer) {
        console.log(`Showing subcategory container for ${category}`);
        subcategoryContainer.style.display = 'flex';
        
        // Find and activate the "All" tab (or first tab if no "All")
        const allTab = subcategoryContainer.querySelector('.item-subcategory-tab[data-subcategory="All"]');
        if (allTab) {
            // Reset all tabs in this container
            subcategoryContainer.querySelectorAll('.item-subcategory-tab').forEach(tab => {
                tab.classList.remove('active');
                tab.style.backgroundColor = '#e0e0e0';
                tab.style.color = '#333';
            });
            
            // Activate the "All" tab
            allTab.classList.add('active');
            allTab.style.backgroundColor = '#4a7de9';
            allTab.style.color = 'white';
            
            // Update state
            window.currentItemSubcategory = 'All';
        }
    } else {
        // If no subcategory, just reset to 'All'
        window.currentItemSubcategory = 'All';
    }
    
    // Update our state
    window.currentItemCategory = category;
    
    // Apply the filters
    applyItemFilters();
}
function handleSubcategoryChange(subcategory, clickedTab) {
    // Find the container of this tab
    const container = clickedTab.closest('.item-subcategory-tabs');
    if (!container) return;
    
    // Reset all tabs in this container
    container.querySelectorAll('.item-subcategory-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
    });
    
    // Make the clicked tab active
    clickedTab.classList.add('active');
    clickedTab.style.backgroundColor = '#4a7de9';
    clickedTab.style.color = 'white';
    
    // Update our state
    window.currentItemSubcategory = subcategory;
    
    // Apply the filters
    applyItemFilters();
}
// Updated applyItemFilters function to specifically handle Warframes
function applyItemFilters() {
    console.log(`Applying item filters: ${window.currentItemCategory} > ${window.currentItemSubcategory}`);
    
    // Get all item cards
    const itemCards = document.querySelectorAll('#item-inventory .inventory-resource-card');
    if (itemCards.length === 0) {
        console.log("No item cards found to filter!");
        return;
    }
    
    console.log(`Found ${itemCards.length} item cards to filter`);
    let matchCount = 0;
    
    // Debug: Check the category names in our data
    if (!window.categoriesLogged) {
        // Get unique categories for debugging
        const uniqueCategories = [...new Set(items.map(item => item.category))];
        console.log("Available item categories:", uniqueCategories);
        window.categoriesLogged = true;
    }
    
    itemCards.forEach(card => {
        // Extract item name and find corresponding item data
        const nameEl = card.querySelector('.resource-name');
        if (!nameEl) return;
        
        // Get clean item name (without mastery status)
        const fullText = nameEl.textContent;
        // Find the mastery indicator if it exists and extract just the name
let endIndex = fullText.indexOf('Mastered');
if (endIndex === -1) endIndex = fullText.indexOf('Unmastered');

const itemName = endIndex !== -1
    ? fullText.substring(0, endIndex).trim()
    : fullText.trim();

        
        // Find the item data
        const itemData = items.find(i => i.name === itemName);
        if (!itemData) {
            console.log(`Item not found in data: "${itemName}"`);
            card.style.display = 'none';
            return;
        }
        
        let shouldDisplay = false;
        
        // Handle "All" category which should show everything
        if (window.currentItemCategory === 'All') {
            shouldDisplay = true;
        }
        // Specific handling for Warframes (handle both plural and singular forms)
        else if (window.currentItemCategory === 'Warframes') {
            // Check both "Warframes" and "Warframe" category names
            shouldDisplay = itemData.category === 'Warframes' || 
                           itemData.category === 'Warframe';
        }
        // Handle specific main categories
        else if (window.currentItemCategory === 'Weapons') {
            const weaponTypes = ['Primary Weapon', 'Secondary Weapon', 'Melee Weapon', 
                                'Archgun', 'Arch-Melee', 'Kitgun', 'Zaw', 'Amp', 'Robotic Weapon'];
            shouldDisplay = weaponTypes.includes(itemData.category);
            
            // Further filter by weapon subcategory if not "All"
            if (shouldDisplay && window.currentItemSubcategory !== 'All') {
                shouldDisplay = itemData.category === window.currentItemSubcategory;
            }
        }
        else if (window.currentItemCategory === 'Vehicles') {
            const vehicleTypes = ['Archwings', 'Necramech', 'K-Drive'];
            shouldDisplay = vehicleTypes.includes(itemData.category);
            
            // Further filter by vehicle subcategory if not "All"
            if (shouldDisplay && window.currentItemSubcategory !== 'All') {
                shouldDisplay = itemData.category === window.currentItemSubcategory;
            }
        }
        else if (window.currentItemCategory === 'Companions') {
            const companionTypes = ['Sentinel', 'MOA', 'Hound', 'Infested Companion'];
            shouldDisplay = companionTypes.includes(itemData.category) || 
                           (itemData.category === 'Companion');
            
            // Further filter by companion subcategory if not "All"
            if (shouldDisplay && window.currentItemSubcategory !== 'All') {
                if (window.currentItemSubcategory === 'Robotic') {
                    shouldDisplay = ['Sentinel', 'MOA', 'Hound'].includes(itemData.category);
                } else if (window.currentItemSubcategory === 'Organic') {
                    shouldDisplay = itemData.category === 'Infested Companion' || 
                                   (itemData.category === 'Companion');
                }
            }
        }
        // For Component tab, handle different potential name formats
        else if (window.currentItemCategory === 'Component') {
            shouldDisplay = itemData.category === 'Component' || 
                           itemData.category === 'Components' ||
                           itemData.category === 'Parts';
        }
        // For other main categories, try several variations of the name
        else {
            const categoryToCheck = window.currentItemCategory;
            // Check exact match
            shouldDisplay = itemData.category === categoryToCheck;
            
            // If no match, try singular form (if current is plural)
            if (!shouldDisplay && categoryToCheck.endsWith('s')) {
                shouldDisplay = itemData.category === categoryToCheck.slice(0, -1);
            }
            
            // If still no match, try plural form (if current is singular)
            if (!shouldDisplay && !categoryToCheck.endsWith('s')) {
                shouldDisplay = itemData.category === categoryToCheck + 's';
            }
        }
        
        // Apply the display status
        card.style.display = shouldDisplay ? '' : 'none';
        
        // Count matches for "no results" message
        if (shouldDisplay) {
            matchCount++;
        }
    });
    
    console.log(`Filter applied: ${matchCount} items matched`);
    
    // Handle "no matches" message
    const noMatchMessage = document.querySelector('#item-inventory .no-match-message');
    
    if (matchCount === 0) {
        // Create "no matches" message if it doesn't exist
        if (!noMatchMessage) {
            const message = document.createElement('div');
            message.className = 'empty-message no-match-message';
            message.textContent = `No items found in category: ${window.currentItemCategory}${
                window.currentItemSubcategory !== 'All' ? ` > ${window.currentItemSubcategory}` : ''}`;
            
            const container = document.getElementById('item-inventory');
            if (container) {
                container.appendChild(message);
            }
        }
    } else {
        // Remove "no matches" message if it exists
        if (noMatchMessage) {
            noMatchMessage.remove();
        }
    }
}
function handleItemCategoryTabClick(event) {
    const categoryTab = event.currentTarget;
    const category = categoryTab.getAttribute('data-category');
    
    console.log(`Category tab clicked: ${category}`);
    
    // Update active state for all main tabs
    document.querySelectorAll('.item-category-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
    });
    
    // Set this tab as active
    categoryTab.classList.add('active');
    categoryTab.style.backgroundColor = '#4a7de9';
    categoryTab.style.color = 'white';
    
    // Hide all subcategory tab sets
    document.querySelectorAll('.item-subcategory-tabs').forEach(tabSet => {
        tabSet.style.display = 'none';
    });
    
    // Reset subcategory to All
    window.currentItemSubcategory = 'All';
    
    // Show related subcategory tabs if applicable
    if (category === 'Vehicles') {
        const vehicleTabs = document.querySelector('.vehicle-tabs');
        if (vehicleTabs) {
            vehicleTabs.style.display = 'flex';
            resetSubcategoryTabs('.vehicle-tabs');
        }
    } else if (category === 'Weapons') {
        const weaponTabs = document.querySelector('.weapon-tabs');
        if (weaponTabs) {
            weaponTabs.style.display = 'flex';
            resetSubcategoryTabs('.weapon-tabs');
        }
    } else if (category === 'Companions') {
        const companionTabs = document.querySelector('.companion-tabs');
        if (companionTabs) {
            companionTabs.style.display = 'flex';
            resetSubcategoryTabs('.companion-tabs');
        }
    }
    
    // Update current category
    window.currentItemCategory = category;
    
    // Filter items based on new category
    filterItemsByCategory();
}

function handleItemSubcategoryTabClick(event) {
    const subcategoryTab = event.currentTarget;
    const subcategory = subcategoryTab.getAttribute('data-subcategory');
    
    console.log(`Subcategory tab clicked: ${subcategory}`);
    
    // Find the parent tab set
    const parentTabSet = subcategoryTab.closest('.item-subcategory-tabs');
    if (!parentTabSet) return;
    
    // Update active state within this tab set only
    parentTabSet.querySelectorAll('.item-subcategory-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
    });
    
    // Set this tab as active
    subcategoryTab.classList.add('active');
    subcategoryTab.style.backgroundColor = '#4a7de9';
    subcategoryTab.style.color = 'white';
    
    // Update current subcategory
    window.currentItemSubcategory = subcategory;
    
    // Filter items based on updated subcategory
    filterItemsByCategory();
}

function resetSubcategoryTabs(selector) {
    const tabSet = document.querySelector(selector);
    if (!tabSet) return;
    
    tabSet.querySelectorAll('.item-subcategory-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
        
        if (tab.getAttribute('data-subcategory') === 'All') {
            tab.classList.add('active');
            tab.style.backgroundColor = '#4a7de9';
            tab.style.color = 'white';
        }
    });
}

function filterItemsByCategory() {
    console.log(`Filtering by: ${window.currentItemCategory} > ${window.currentItemSubcategory}`);
    
    const itemCards = document.querySelectorAll('#item-inventory .inventory-resource-card');
    console.log(`Found ${itemCards.length} item cards to filter`);
    
    let visibleCount = 0;
    
    itemCards.forEach(card => {
        // Get the item name from the card
        const nameElement = card.querySelector('.resource-name');
        if (!nameElement) return;
        
        // Extract just the item name (before any mastery indicator)
        const fullText = nameElement.textContent;
        const itemName = fullText.split(/\s+/)[0]; // Get the first word (name)
        
        // Find the item in our data
        const item = items.find(i => i.name === itemName);
        if (!item) {
            console.log(`Item not found in data: ${itemName}`);
            return;
        }
        
        // Determine if this item should be visible
        let visible = true;
        
        // Filter by main category
        if (window.currentItemCategory !== 'All') {
            if (window.currentItemCategory === 'Weapons') {
                const weaponCategories = ['Primary Weapon', 'Secondary Weapon', 'Melee Weapon', 
                                          'Archgun', 'Arch-Melee', 'Kitgun', 'Zaw', 'Amp', 'Robotic Weapon'];
                visible = weaponCategories.includes(item.category);
            } 
            else if (window.currentItemCategory === 'Vehicles') {
                const vehicleCategories = ['Archwings', 'Necramech', 'K-Drive'];
                visible = vehicleCategories.includes(item.category);
            }
            else if (window.currentItemCategory === 'Companions') {
                visible = ['Sentinel', 'MOA', 'Hound', 'Infested Companion'].includes(item.category) ||
                         (item.category === 'Companion');
            }
            else {
                // For other categories, must match exactly
                visible = (item.category === window.currentItemCategory);
            }
            
            // Further filter by subcategory if applicable
            if (visible && window.currentItemSubcategory !== 'All') {
                if (window.currentItemCategory === 'Weapons') {
                    visible = (item.category === window.currentItemSubcategory);
                }
                else if (window.currentItemCategory === 'Vehicles') {
                    visible = (item.category === window.currentItemSubcategory);
                }
                else if (window.currentItemCategory === 'Companions') {
                    if (window.currentItemSubcategory === 'Robotic') {
                        visible = ['Sentinel', 'MOA', 'Hound'].includes(item.category);
                    } else if (window.currentItemSubcategory === 'Organic') {
                        visible = (item.category === 'Infested Companion') ||
                                 (item.category === 'Companion');
                    }
                }
            }
        }
        
        // Show or hide the card
        card.style.display = visible ? '' : 'none';
        if (visible) visibleCount++;
    });
    
    console.log(`${visibleCount} items visible after filtering`);
    
    // Update or add "no matches" message if needed
    updateNoMatchesMessage(visibleCount);
}
function updateNoMatchesMessage(visibleCount) {
    const container = document.getElementById('item-inventory');
    if (!container) return;
    
    // Remove any existing message
    const existingMessage = container.querySelector('.no-match-message');
    if (existingMessage) {
        existingMessage.remove();
    }
    
    // Add a new message if no items are visible
    if (visibleCount === 0) {
        const message = document.createElement('div');
        message.className = 'empty-message no-match-message';
        message.textContent = `No items found in category: ${window.currentItemCategory}${
            window.currentItemSubcategory !== 'All' ? ` > ${window.currentItemSubcategory}` : ''}`;
        container.appendChild(message);
    }
}

function matchesCategory(item) {
    if (!item || !item.category) return false;
    
    if (window.currentItemCategory === 'All') {
        return true;
    }
    
    // Handle the "Parts" tab (mapped to Component category)
    if (window.currentItemCategory === 'Component') {
        return item.category === 'Component';
    }
    
    // Handle exact category matches
    if (window.currentItemCategory === item.category) {
        if (window.currentItemSubcategory === 'All') {
            return true;
        }
        
        // Subcategory matching depends on the parent category
        if (window.currentItemCategory === 'Vehicles') {
            return matchesVehicleSubcategory(item);
        } else if (window.currentItemCategory === 'Weapons') {
            return matchesWeaponSubcategory(item);
        } else if (window.currentItemCategory === 'Companions') {
            return matchesCompanionSubcategory(item);
        }
        
        return true;
    }
    
    // Special case for Vehicles
    if (window.currentItemCategory === 'Vehicles') {
        const vehicleCategories = ['Archwings', 'Necramech', 'K-Drive'];
        if (vehicleCategories.includes(item.category)) {
            if (window.currentItemSubcategory === 'All') {
                return true;
            }
            return matchesVehicleSubcategory(item);
        }
    }
    
    // Special case for Weapons
    if (window.currentItemCategory === 'Weapons') {
        const weaponCategories = [
            'Primary Weapon', 'Secondary Weapon', 'Melee Weapon', 
            'Archgun', 'Arch-Melee', 'Kitgun', 'Zaw', 'Amp', 'Robotic Weapon'
        ];
        
        if (weaponCategories.includes(item.category)) {
            if (window.currentItemSubcategory === 'All') {
                return true;
            }
            return matchesWeaponSubcategory(item);
        }
    }
    
    // Special case for Companions
    if (window.currentItemCategory === 'Companions') {
        if (isCompanion(item)) {
            if (window.currentItemSubcategory === 'All') {
                return true;
            }
            return matchesCompanionSubcategory(item);
        }
    }
    
    return false;
}

function matchesVehicleSubcategory(item) {
    if (window.currentItemSubcategory === 'All') {
        return true;
    } else if (window.currentItemSubcategory === item.category) {
        return true;
    }
    return false;
}

function matchesWeaponSubcategory(item) {
    if (window.currentItemSubcategory === 'All') {
        return true;
    } else if (window.currentItemSubcategory === item.category) {
        return true;
    }
    
    // Special case for "Companion" weapons tab (which shows Robotic Weapons)
    if (window.currentItemSubcategory === 'Robotic Weapon' && item.category === 'Robotic Weapon') {
        return true;
    }
    
    return false;
}

function matchesCompanionSubcategory(item) {
    if (window.currentItemSubcategory === 'All') {
        return true;
    } else if (window.currentItemSubcategory === 'Robotic') {
        // Robotic companions include Sentinel, MOA, and Hound
        return item.category === 'Sentinel' || 
               item.category === 'MOA' || 
               item.category === 'Hound';
    } else if (window.currentItemSubcategory === 'Organic') {
        // Organic companions include Infested Companion and possibly others
        return item.category === 'Infested Companion' ||
              (item.category === 'Companion' && 
               (item.name.includes('Kubrow') || item.name.includes('Kavat')));
    }
    return false;
}

function isCompanion(item) {
    return item.category === 'Sentinel' || 
           item.category === 'MOA' || 
           item.category === 'Hound' ||
           item.category === 'Infested Companion' ||
          (item.category === 'Companion' && 
           (item.name.includes('Kubrow') || item.name.includes('Kavat')));
}

function enhanceItemSearchWithCategoryFilter() {
    // Get the original search function
    const originalFilterFn = window.filterInventoryItems;
    
    // Only override if it exists
    if (originalFilterFn) {
        window.filterInventoryItems = function() {
            // Call original search function first
            originalFilterFn();
            
            // Then reapply our category filtering
            filterItemsByCategory();
        };
    }
}

// 3. Handle main category tab clicks
function handleItemCategoryTabClick(event) {
    const categoryTab = event.target;
    const category = categoryTab.getAttribute('data-category');
    
    // Update active state for all main tabs
    document.querySelectorAll('.item-category-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
    });
    
    // Set this tab as active
    categoryTab.classList.add('active');
    categoryTab.style.backgroundColor = '#4a7de9';
    categoryTab.style.color = 'white';
    
    // Hide all subcategory tabs
    document.querySelectorAll('.item-subcategory-tabs').forEach(tabSet => {
        tabSet.style.display = 'none';
    });
    
    // Reset subcategory to All
    currentItemSubcategory = 'All';
    
    // Show related subcategory tabs if applicable
    if (category === 'Vehicles') {
        document.querySelector('.vehicle-tabs').style.display = 'flex';
        resetSubcategoryTabs('.vehicle-tabs');
    } else if (category === 'Weapons') {
        document.querySelector('.weapon-tabs').style.display = 'flex';
        resetSubcategoryTabs('.weapon-tabs');
    } else if (category === 'Companions') {
        document.querySelector('.companion-tabs').style.display = 'flex';
        resetSubcategoryTabs('.companion-tabs');
    }
    
    // Update current category
    currentItemCategory = category;
    
    // Filter items based on new category
    filterItemsByCategory();
}

// 4. Handle subcategory tab clicks
function handleItemSubcategoryTabClick(event) {
    const subcategoryTab = event.target;
    const subcategory = subcategoryTab.getAttribute('data-subcategory');
    
    // Find the parent tab set
    const parentTabSet = subcategoryTab.closest('.item-subcategory-tabs');
    if (!parentTabSet) return;
    
    // Update active state within this tab set only
    parentTabSet.querySelectorAll('.item-subcategory-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
    });
    
    // Set this tab as active
    subcategoryTab.classList.add('active');
    subcategoryTab.style.backgroundColor = '#4a7de9';
    subcategoryTab.style.color = 'white';
    
    // Update current subcategory
    currentItemSubcategory = subcategory;
    
    // Filter items based on updated subcategory
    filterItemsByCategory();
}

// 5. Reset subcategory tabs to "All" active
function resetSubcategoryTabs(selector) {
    const tabSet = document.querySelector(selector);
    if (!tabSet) return;
    
    tabSet.querySelectorAll('.item-subcategory-tab').forEach(tab => {
        tab.classList.remove('active');
        tab.style.backgroundColor = '#e0e0e0';
        tab.style.color = '#333';
        
        if (tab.getAttribute('data-subcategory') === 'All') {
            tab.classList.add('active');
            tab.style.backgroundColor = '#4a7de9';
            tab.style.color = 'white';
        }
    });
}

// 6. Main filtering function
function filterItemsByCategory() {
    const itemCards = document.querySelectorAll('#item-inventory .inventory-resource-card');
    
    itemCards.forEach(card => {
        // Get the item name from the card
        const itemNameElement = card.querySelector('.resource-name');
        if (!itemNameElement) return;
        
        const itemName = itemNameElement.textContent;
        
        // Find the item object
        const item = items.find(i => i.name === itemName);
        if (!item) return;
        
        // Check if item matches current filters
        let matches = matchesCategory(item);
        
        // Show or hide the card
        card.style.display = matches ? '' : 'none';
    });
    
    // Add a message if no items match
    const noMatchMessage = document.querySelector('#item-inventory .no-match-message');
    const visibleCards = Array.from(itemCards).filter(card => card.style.display !== 'none');
    
    if (visibleCards.length === 0) {
        if (!noMatchMessage) {
            const message = document.createElement('div');
            message.className = 'empty-message no-match-message';
            message.textContent = `No items found in category: ${currentItemCategory}${currentItemSubcategory !== 'All' ? ` > ${currentItemSubcategory}` : ''}`;
            document.getElementById('item-inventory').appendChild(message);
        }
    } else if (noMatchMessage) {
        noMatchMessage.remove();
    }
}
function filterResourcesByLocation(location) {
    const resourceCards = document.querySelectorAll('#resource-inventory .inventory-resource-card');
    
    console.log(`Filtering resources by location: ${location}`);
    console.log(`Found ${resourceCards.length} resource cards`);
    
    let visibleCount = 0;
    
    resourceCards.forEach(card => {
        // Get the resource name
        const resourceNameElement = card.querySelector('.resource-name');
        if (!resourceNameElement) return;
        
        const resourceName = resourceNameElement.textContent;
        
        // Find the resource object
        const resource = resources.find(r => r.name === resourceName);
        if (!resource) {
            console.log(`Resource not found in data: ${resourceName}`);
            return;
        }
        
        // If resource has no locations array, create an empty one to avoid errors
        if (!resource.locations) {
            resource.locations = [];
        }
        
        // Check if resource is in the selected location
        let matches = false;
        
        if (location === 'All') {
            matches = true;
        } else if (location === 'Star Chart') {
            matches = resource.locations.some(loc => isStarChartPlanet(loc));
        } else {
            matches = resource.locations.includes(location);
        }
        
        // Show or hide the card
        card.style.display = matches ? '' : 'none';
        
        // Count visible resources
        if (matches) {
            visibleCount++;
        }
    });
    
    console.log(`Filter applied: ${visibleCount} resources visible`);
    
    // Add "no match" message if needed
    const noMatchMessage = document.querySelector('#resource-inventory .no-match-message');
    
    if (visibleCount === 0) {
        if (!noMatchMessage) {
            const message = document.createElement('div');
            message.className = 'empty-message no-match-message';
            message.textContent = `No resources found in location: ${location}`;
            document.getElementById('resource-inventory').appendChild(message);
        }
    } else if (noMatchMessage) {
        noMatchMessage.remove();
    }
}

// 7. Function to check if an item matches the current category/subcategory
function matchesCategory(item) {
    if (currentItemCategory === 'All') {
        return true;
    }
    
    // Handle the "Parts" tab (mapped to Component category)
    if (currentItemCategory === 'Component') {
        return item.category === 'Component';
    }
    
    // Handle exact category matches
    if (currentItemCategory === item.category) {
        if (currentItemSubcategory === 'All') {
            return true;
        }
        
        // Subcategory matching depends on the parent category
        if (currentItemCategory === 'Vehicles') {
            return matchesVehicleSubcategory(item);
        } else if (currentItemCategory === 'Weapons') {
            return matchesWeaponSubcategory(item);
        } else if (currentItemCategory === 'Companions') {
            return matchesCompanionSubcategory(item);
        }
        
        return true;
    }
    
    // Special case for Vehicles
    if (currentItemCategory === 'Vehicles') {
        const vehicleCategories = ['Archwings', 'Necramech', 'K-Drive'];
        if (vehicleCategories.includes(item.category)) {
            if (currentItemSubcategory === 'All') {
                return true;
            }
            return matchesVehicleSubcategory(item);
        }
    }
    
    // Special case for Weapons
    if (currentItemCategory === 'Weapons') {
        const weaponCategories = [
            'Primary Weapon', 'Secondary Weapon', 'Melee Weapon', 
            'Archgun', 'Arch-Melee', 'Kitgun', 'Zaw', 'Amp', 'Robotic Weapon'
        ];
        
        if (weaponCategories.includes(item.category)) {
            if (currentItemSubcategory === 'All') {
                return true;
            }
            return matchesWeaponSubcategory(item);
        }
    }
    
    // Special case for Companions
    if (currentItemCategory === 'Companions') {
        if (isCompanion(item)) {
            if (currentItemSubcategory === 'All') {
                return true;
            }
            return matchesCompanionSubcategory(item);
        }
    }
    
    return false;
}

// 8. Subcategory matching helper functions
function matchesVehicleSubcategory(item) {
    if (currentItemSubcategory === 'Archwings') {
        return item.category === 'Archwings';
    } else if (currentItemSubcategory === 'Necramech') {
        return item.category === 'Necramech';
    } else if (currentItemSubcategory === 'K-Drive') {
        return item.category === 'K-Drive';
    }
    return false;
}

function matchesWeaponSubcategory(item) {
    // Direct match for most weapon types
    if (currentItemSubcategory === item.category) {
        return true;
    }
    
    // Special case for "Companion" weapons tab (which shows Robotic Weapons)
    if (currentItemSubcategory === 'Robotic Weapon' && item.category === 'Robotic Weapon') {
        return true;
    }
    
    return false;
}

function matchesCompanionSubcategory(item) {
    if (currentItemSubcategory === 'Robotic') {
        // Robotic companions include Sentinel, MOA, and Hound
        return item.category === 'Sentinel' || 
               item.category === 'MOA' || 
               item.category === 'Hound';
    } else if (currentItemSubcategory === 'Organic') {
        // Organic companions include Infested Companion and possibly others
        return item.category === 'Infested Companion' ||
              (item.category === 'Companion' && 
               (item.name.includes('Kubrow') || item.name.includes('Kavat')));
    }
    return false;
}

// 9. Helper function to identify companions
function isCompanion(item) {
    return item.category === 'Sentinel' || 
           item.category === 'MOA' || 
           item.category === 'Hound' ||
           item.category === 'Infested Companion' ||
          (item.category === 'Companion' && 
           (item.name.includes('Kubrow') || item.name.includes('Kavat')));
}

// 10. Enhance search to maintain category filtering
function enhanceItemSearchWithCategoryFilter() {
    // Get the original search function
    const originalFilterFn = window.filterInventoryItems;
    
    // Only override if it exists
    if (originalFilterFn) {
        window.filterInventoryItems = function() {
            // Call original search function first
            originalFilterFn();
            
            // Then reapply our category filtering
            filterItemsByCategory();
        };
    }
}

// 11. Add initialization to inventory tab activation
document.addEventListener('DOMContentLoaded', function() {
    // If inventory tab is already active, initialize now
    if (document.querySelector('.tab[data-tab="inventory"]')?.classList.contains('active')) {
        initializeItemCategoryTabs();
    }
    
    // Initialize when inventory tab becomes active
    document.addEventListener('inventoryTabActivated', function() {
        initializeItemCategoryTabs();
    });
    
    // Adjust renderInventory function to preserve filtering
    const originalRenderInventory = window.renderInventory;
    if (originalRenderInventory) {
        window.renderInventory = function() {
            // Store active category and subcategory
            const savedCategory = currentItemCategory;
            const savedSubcategory = currentItemSubcategory;
            
            // Call original render function
            originalRenderInventory();
            
            // Restore category and subcategory
            currentItemCategory = savedCategory;
            currentItemSubcategory = savedSubcategory;
            
            // Reapply filtering if not showing all
            if (currentItemCategory !== 'All') {
                setTimeout(() => {
                    filterItemsByCategory();
                }, 0);
            }
        };
    }
});
function updateAndSaveData(dataType, extraActions = {}) {
    switch(dataType) {
        case 'resources':
            saveResources();
            if (extraActions.renderResources !== false) renderResources();
            if (extraActions.populateSelects !== false) populateResourceAndItemSelects();
            break;
        case 'items':
            saveItems();
            if (extraActions.renderItems !== false) renderItems();
            if (extraActions.populateSelects !== false) populateResourceAndItemSelects();
            break;
        case 'inventory':
            saveInventory();
            if (extraActions.renderInventory !== false) renderInventory();
            break;
        case 'syndicates':
            saveSyndicates();
            if (extraActions.renderSyndicates !== false) renderSyndicates();
            break;
        case 'all':
            saveResources();
            saveItems();
            saveInventory();
            saveSyndicates();
            break;
    }
    
    // Show notification with custom message or default
    showNotification(extraActions.message || `${dataType.charAt(0).toUpperCase() + dataType.slice(1)} updated successfully!`);
    
    // Call any custom functions provided
    if (typeof extraActions.callback === 'function') {
        extraActions.callback();
    }
}
/**
 * Helper function to update the text content of multiple DOM elements efficiently
 * @param {Object} updates - Object with element IDs as keys and new content as values
 */
function updateElementTexts(updates) {
    // Create a document fragment to avoid multiple reflows
    const fragment = document.createDocumentFragment();
    const tempElements = {};
    
    // First pass: clone elements and update them in the fragment
    for (const [id, content] of Object.entries(updates)) {
        const element = document.getElementById(id);
        if (element) {
            const clone = element.cloneNode(true);
            clone.textContent = content;
            tempElements[id] = clone;
            fragment.appendChild(clone);
        }
    }
    
    // Second pass: replace the original elements with their updated clones
    for (const [id, clone] of Object.entries(tempElements)) {
        const element = document.getElementById(id);
        if (element && element.parentNode) {
            element.parentNode.replaceChild(clone, element);
        }
    }
}

/**
 * Helper function to update image error handling for all images
 */
function enhanceImageErrorHandling() {
    document.querySelectorAll('img').forEach(img => {
        if (!img.hasAttribute('data-error-handled')) {
            img.setAttribute('data-error-handled', 'true');
            img.onerror = function() {
                this.onerror = null; // Prevent infinite loops
                const type = this.alt.toLowerCase().includes('resource') ? '📦' : '🔨';
                this.src = `https://via.placeholder.com/${this.width || 50}x${this.height || 50}?text=${type}`;
                this.style.opacity = 0.7;
            };
        }
    });
}
function activateFirstSubcategoryTab(container) {
    if (!container) return;
    
    const allTabs = container.querySelectorAll('.item-subcategory-tab');
    console.log(`Found ${allTabs.length} subcategory tabs in container`);
    
    // Reset all tabs in container
    allTabs.forEach(t => {
        t.classList.remove('active');
        t.style.backgroundColor = '#e0e0e0';
        t.style.color = '#333';
    });
    
    // Find and activate the "All" tab if it exists
    const allTab = Array.from(allTabs).find(tab => 
        tab.getAttribute('data-subcategory') === 'All');
    
    if (allTab) {
        console.log('Activating "All" subcategory tab');
        allTab.classList.add('active');
        allTab.style.backgroundColor = '#4a7de9';
        allTab.style.color = 'white';
    } else if (allTabs.length > 0) {
        // If no "All" tab, activate the first tab
        console.log('No "All" tab found, activating first subcategory tab');
        allTabs[0].classList.add('active');
        allTabs[0].style.backgroundColor = '#4a7de9';
        allTabs[0].style.color = 'white';
    }
}
// Add this function to fix any CSS issues
function fixTabStyles() {
    console.log("Fixing tab styles");
    
    // Fix tab containers
    document.querySelectorAll('.item-subcategory-tabs').forEach(container => {
        container.style.margin = '10px 0';
        container.style.padding = '5px';
        container.style.background = '#f0f0f0';
        container.style.borderRadius = '4px';
        container.style.display = 'none'; // Hidden by default
        container.style.flexWrap = 'wrap';
    });
    
    // Fix individual tabs
    document.querySelectorAll('.item-subcategory-tab').forEach(tab => {
        tab.style.padding = '6px 10px';
        tab.style.margin = '2px';
        tab.style.border = 'none';
        tab.style.borderRadius = '3px';
        tab.style.background = '#e0e0e0';
        tab.style.color = '#333';
        tab.style.cursor = 'pointer';
        tab.style.fontWeight = '500';
        tab.style.transition = 'background-color 0.3s';
        tab.style.fontSize = '0.9em';
    });
    
    // Ensure active tabs are properly styled
    document.querySelectorAll('.item-subcategory-tab.active').forEach(tab => {
        tab.style.backgroundColor = '#4a7de9';
        tab.style.color = 'white';
    });
}

// Simple debugging script - no dependencies
document.addEventListener('DOMContentLoaded', function() {
    // Add a debug button that will run immediately
    const debugBtn = document.createElement('button');
    debugBtn.innerText = 'Debug Items';
    debugBtn.style.position = 'fixed';
    debugBtn.style.bottom = '10px';
    debugBtn.style.right = '10px';
    debugBtn.style.zIndex = '9999';
    debugBtn.style.padding = '10px';
    debugBtn.style.backgroundColor = '#ff5722';
    debugBtn.style.color = 'white';
    debugBtn.style.border = 'none';
    debugBtn.style.borderRadius = '4px';
    debugBtn.style.cursor = 'pointer';
    
    debugBtn.onclick = function() {
        console.clear();
        console.log("------- ITEM DEBUG -------");
        
        // 1. Check if items array exists and has items
        console.log(`Items array exists: ${typeof items !== 'undefined'}`);
        console.log(`Items count: ${typeof items !== 'undefined' ? items.length : 'N/A'}`);
        
        // 2. Check for Warframes in the items array
        if (typeof items !== 'undefined' && items.length > 0) {
            const categories = {};
            const warframes = [];
            
            items.forEach(item => {
                // Count categories
                const cat = item.category || 'Uncategorized';
                categories[cat] = (categories[cat] || 0) + 1;
                
                // Check for Warframes
                if (cat === 'Warframes' || cat === 'Warframe' || 
                    (item.name && item.name.toLowerCase().includes('warframe'))) {
                    warframes.push(item);
                }
            });
            
            console.log("Categories in items array:");
            Object.entries(categories)
                .sort((a, b) => b[1] - a[1])
                .forEach(([cat, count]) => {
                    console.log(`- ${cat}: ${count}`);
                });
            
            console.log(`Found ${warframes.length} Warframes in data`);
            if (warframes.length > 0) {
                console.log("Sample Warframes:");
                warframes.slice(0, 5).forEach(wf => {
                    console.log(`- ${wf.name} (Category: ${wf.category})`);
                });
            }
        }
        
        // 3. Check the DOM for item-inventory elements
        const itemContainer = document.getElementById('item-inventory');
        console.log(`Item inventory container exists: ${!!itemContainer}`);
        
        if (itemContainer) {
            const cards = itemContainer.querySelectorAll('.inventory-resource-card');
            console.log(`Total item cards in DOM: ${cards.length}`);
            
            // Check categories in DOM
            const domCategories = {};
            cards.forEach(card => {
                const catElement = card.querySelector('.resource-rarity');
                if (catElement) {
                    const category = catElement.textContent;
                    domCategories[category] = (domCategories[category] || 0) + 1;
                }
            });
            
            console.log("Categories in DOM:");
            Object.entries(domCategories)
                .sort((a, b) => b[1] - a[1])
                .forEach(([cat, count]) => {
                    console.log(`- ${cat}: ${count}`);
                });
            
            // Check for Warframe cards specifically
            const warframeCards = Array.from(cards).filter(card => {
                const catElement = card.querySelector('.resource-rarity');
                return catElement && 
                      (catElement.textContent === 'Warframes' || 
                       catElement.textContent === 'Warframe');
            });
            
            console.log(`Warframe cards in DOM: ${warframeCards.length}`);
            
            // Check tab state
            console.log(`Current tab category: ${window.currentItemCategory || 'Not set'}`);
            console.log(`Current tab subcategory: ${window.currentItemSubcategory || 'Not set'}`);
            
            // Force all Warframes to be visible for testing
            if (warframeCards.length > 0) {
                console.log("Making all Warframe cards visible for testing");
                warframeCards.forEach(card => {
                    card.style.display = '';
                });
            }
        }
        
        console.log("------- END DEBUG -------");
    };
    
    document.body.appendChild(debugBtn);
    
    // Auto-run after a delay
    setTimeout(function() {
        console.log("Auto-running debug...");
        debugBtn.click();
    }, 3000);
});
function ensureTabsInitialized() {
    // Remove any previous inventory tab activation listener to prevent duplication
    const oldListeners = window._inventoryTabListeners || [];
    oldListeners.forEach(listener => {
        document.removeEventListener('inventoryTabActivated', listener);
    });
    
    // Create a new listener function
    const newListener = function() {
        console.log("Inventory tab activated - initializing tabs");
        
        // Force re-initialization of the tabs
        window.itemTabsInitialized = false;
        window.locationTabsInitialized = false;
        
        // Initialize tabs with a slight delay to ensure DOM is ready
        setTimeout(() => {
            initializeItemCategoryTabs();
            initializeLocationTabs(true);
            fixTabStyles();
        }, 300);
    };
    
    // Store the new listener
    window._inventoryTabListeners = [newListener];
    
    // Add the new listener
    document.addEventListener('inventoryTabActivated', newListener);
    
    // Also check if inventory tab is already active
    if (document.querySelector('.tab[data-tab="inventory"]')?.classList.contains('active')) {
        console.log("Inventory tab is already active - initializing tabs");
        initializeItemCategoryTabs();
        initializeLocationTabs(true);
        fixTabStyles();
    }
}
document.addEventListener('DOMContentLoaded', function() {
    ensureTabsInitialized();
    
    // Modify the tab click handling to properly trigger inventory initialization
    const tabs = document.querySelectorAll('.tab');
    tabs.forEach(tab => {
        const originalClickHandler = tab.onclick;
        
        tab.onclick = function(e) {
            if (originalClickHandler) {
                // Keep original handler
                originalClickHandler.call(this, e);
            }
            
            const tabName = this.getAttribute('data-tab');
            if (tabName === 'inventory') {
                // Dispatch a custom event to trigger initialization
                document.dispatchEvent(new CustomEvent('inventoryTabActivated'));
            }
        };
    });
});

// Call the initialization immediately if the script is executed after the DOM is loaded
if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setTimeout(ensureTabsInitialized, 100);
}
// Track open collapsible sections for the Crafting Calculator only
window.craftingCollapsibleState = {
    componentItems: false,
    rawResources: false,
    // Additional tracking for individual component sources and locations
    componentSources: {},
    resourceLocations: {}
};

// Modified toggleCollapsible function that saves state for crafting calculator sections
function toggleCollapsible(id) {
    const element = document.getElementById(id);
    if (!element) return;
    
    // Toggle the display of the element
    const isCurrentlyVisible = element.style.display !== 'none';
    element.style.display = isCurrentlyVisible ? 'none' : 'block';
    
    // Track state for crafting calculator sections
    if (id === 'component-items-collapsible') {
        window.craftingCollapsibleState.componentItems = !isCurrentlyVisible;
    } else if (id === 'raw-resources-collapsible') {
        window.craftingCollapsibleState.rawResources = !isCurrentlyVisible;
    } else if (id.startsWith('component-source-')) {
        // Track component blueprint source sections
        const itemName = id.replace('component-source-', '');
        window.craftingCollapsibleState.componentSources[itemName] = !isCurrentlyVisible;
    } else if (id.startsWith('locations-')) {
        // Track resource locations sections
        const resourceName = id.replace('locations-', '');
        window.craftingCollapsibleState.resourceLocations[resourceName] = !isCurrentlyVisible;
    }
    
    // Toggle the arrow icon in the button
    const button = document.querySelector(`button[onclick="toggleCollapsible('${id}')"]`);
    if (button) {
        const icon = button.querySelector('.toggle-icon');
        if (icon) {
            icon.textContent = isCurrentlyVisible ? '▼' : '▲';
        }
    }
}
    </script>
</body>
</html>
